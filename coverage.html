
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">kdebug/cmd/cluster.go (0.0%)</option>
				
				<option value="file1">kdebug/cmd/ingress.go (0.0%)</option>
				
				<option value="file2">kdebug/cmd/pod.go (0.0%)</option>
				
				<option value="file3">kdebug/cmd/root.go (0.0%)</option>
				
				<option value="file4">kdebug/cmd/service.go (0.0%)</option>
				
				<option value="file5">kdebug/internal/client/client.go (37.7%)</option>
				
				<option value="file6">kdebug/internal/output/output.go (88.5%)</option>
				
				<option value="file7">kdebug/main.go (0.0%)</option>
				
				<option value="file8">kdebug/pkg/cluster/cluster.go (17.1%)</option>
				
				<option value="file9">kdebug/pkg/ingress/ingress.go (10.2%)</option>
				
				<option value="file10">kdebug/pkg/pod/checks.go (34.9%)</option>
				
				<option value="file11">kdebug/pkg/pod/pod.go (15.9%)</option>
				
				<option value="file12">kdebug/pkg/service/service.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "context"
        "fmt"
        "time"

        "github.com/spf13/cobra"

        "kdebug/internal/client"
        "kdebug/internal/output"
        "kdebug/pkg/cluster"
)

// clusterCmd represents the cluster command
var clusterCmd = &amp;cobra.Command{
        Use:   "cluster",
        Short: "Run comprehensive cluster health checks",
        Long: `Analyze the overall health of your Kubernetes cluster by checking:

‚Ä¢ API Server connectivity and response time
‚Ä¢ Node health and conditions (ready, memory pressure, disk pressure)
‚Ä¢ Control plane components (etcd, scheduler, controller manager)
‚Ä¢ DNS functionality and CoreDNS health
‚Ä¢ Basic cluster configuration

This command provides a quick overview of cluster-wide issues that might
affect workload deployment and operation.`,
        Example: `  # Run all cluster health checks
  kdebug cluster

  # Check only node health
  kdebug cluster --nodes-only

  # Output results as JSON
  kdebug cluster --output json

  # Verbose output with detailed information
  kdebug cluster --verbose

  # Set custom timeout for checks
  kdebug cluster --timeout 30s`,
        RunE: runClusterDiagnostics,
}

func init() <span class="cov0" title="0">{
        // Add cluster command to root
        rootCmd.AddCommand(clusterCmd)

        // Cluster-specific flags
        clusterCmd.Flags().Bool("nodes-only", false, "check only node health (skip control plane and DNS checks)")
        clusterCmd.Flags().Duration("timeout", 30*time.Second, "timeout for cluster checks")
}</span>

// runClusterDiagnostics executes the cluster diagnostic checks
func runClusterDiagnostics(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Get flag values
        nodesOnly, _ := cmd.Flags().GetBool("nodes-only")
        timeout, _ := cmd.Flags().GetDuration("timeout")

        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // Initialize output manager
        outputMgr := output.NewOutputManager(outputFormat, verbose)

        // Print initial info
        if verbose </span><span class="cov0" title="0">{
                outputMgr.PrintInfo("Starting cluster diagnostics...")
                outputMgr.PrintInfo(fmt.Sprintf("Timeout: %v", timeout))

                if kubeconfig != "" </span><span class="cov0" title="0">{
                        outputMgr.PrintInfo(fmt.Sprintf("Using kubeconfig: %s", kubeconfig))
                }</span>

                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Initialize Kubernetes client
        <span class="cov0" title="0">k8sClient, err := client.NewKubernetesClient(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                outputMgr.PrintError("Failed to initialize Kubernetes client", err)
                return err
        }</span>

        // Test basic connectivity first
        <span class="cov0" title="0">if err := k8sClient.TestConnection(ctx); err != nil </span><span class="cov0" title="0">{
                outputMgr.PrintError("Failed to connect to Kubernetes cluster", err)
                outputMgr.PrintInfo("Please check your kubeconfig and cluster connectivity")

                return err
        }</span>

        // Initialize cluster diagnostic
        <span class="cov0" title="0">clusterDiag := cluster.NewClusterDiagnostic(k8sClient, outputMgr)

        // Run diagnostics
        report, err := clusterDiag.RunDiagnostics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                outputMgr.PrintError("Failed to run cluster diagnostics", err)
                return err
        }</span>

        // Filter results if nodes-only flag is set
        <span class="cov0" title="0">if nodesOnly </span><span class="cov0" title="0">{
                report = filterNodeChecksOnly(report)
        }</span>

        // Print results
        <span class="cov0" title="0">if err := outputMgr.PrintReport(report); err != nil </span><span class="cov0" title="0">{
                outputMgr.PrintError("Failed to print diagnostic report", err)
                return err
        }</span>

        // Print additional information based on results
        <span class="cov0" title="0">if report.Summary.Failed &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println()
                outputMgr.PrintWarning("Some critical issues were found that may affect cluster functionality")
                outputMgr.PrintInfo("Review the failed checks above and follow the suggested actions")

                // Exit with non-zero code if there are critical failures
                return fmt.Errorf("cluster health check failed: %d critical issues found", report.Summary.Failed)
        }</span>

        <span class="cov0" title="0">if report.Summary.Warnings &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println()
                outputMgr.PrintWarning("Some warnings were found that should be addressed")
                outputMgr.PrintInfo("These issues may not immediately affect functionality but should be monitored")
        }</span>

        <span class="cov0" title="0">if report.Summary.Failed == 0 &amp;&amp; report.Summary.Warnings == 0 </span><span class="cov0" title="0">{
                fmt.Println()
                outputMgr.PrintSuccess("Cluster appears to be healthy!")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// filterNodeChecksOnly filters the report to include only node-related checks
func filterNodeChecksOnly(report *output.DiagnosticReport) *output.DiagnosticReport <span class="cov0" title="0">{
        var filteredChecks []output.CheckResult

        for _, check := range report.Checks </span><span class="cov0" title="0">{
                // Include connectivity check and node-related checks
                if check.Name == "API Server Connectivity" ||
                        containsAny(check.Name, []string{"Node", "node"}) </span><span class="cov0" title="0">{
                        filteredChecks = append(filteredChecks, check)
                }</span>
        }

        // Update the report
        <span class="cov0" title="0">newReport := *report
        newReport.Checks = filteredChecks
        newReport.Target = "cluster (nodes only)"

        // Recalculate summary
        newSummary := output.Summary{}
        for _, check := range filteredChecks </span><span class="cov0" title="0">{
                newSummary.Total++

                switch check.Status </span>{
                case output.StatusPassed:<span class="cov0" title="0">
                        newSummary.Passed++</span>
                case output.StatusFailed:<span class="cov0" title="0">
                        newSummary.Failed++</span>
                case output.StatusWarning:<span class="cov0" title="0">
                        newSummary.Warnings++</span>
                case output.StatusSkipped:<span class="cov0" title="0">
                        newSummary.Skipped++</span>
                }
        }

        <span class="cov0" title="0">newReport.Summary = newSummary

        return &amp;newReport</span>
}

// containsAny checks if the string contains any of the given substrings
func containsAny(s string, substrings []string) bool <span class="cov0" title="0">{
        for _, substr := range substrings </span><span class="cov0" title="0">{
                if len(s) &gt;= len(substr) </span><span class="cov0" title="0">{
                        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/spf13/cobra"

        "kdebug/internal/client"
        "kdebug/internal/output"
        "kdebug/pkg/ingress"
)

var ingressCmd = &amp;cobra.Command{
        Use:   "ingress [INGRESS_NAME]",
        Short: "Diagnose Kubernetes ingress resources",
        Long: `Diagnose Kubernetes ingress resources for common issues and misconfigurations.

This command analyzes ingress resources and their dependencies including:
- Ingress existence and configuration
- Backend service availability and configuration
- Service endpoint health
- SSL/TLS certificate validation
- Controller discovery and status

Examples:
  # Diagnose a specific ingress
  kdebug ingress my-ingress

  # Diagnose all ingress resources in current namespace
  kdebug ingress --all

  # Diagnose all ingress resources across all namespaces
  kdebug ingress --all --all-namespaces

  # Run specific checks only
  kdebug ingress my-ingress --checks config,backends,ssl

  # Output in JSON format
  kdebug ingress my-ingress --output json`,
        Args: cobra.MaximumNArgs(1),
        RunE: runIngressDiagnosis,
}

var (
        ingressAll           bool
        ingressAllNamespaces bool
        ingressChecks        []string
        ingressOutputFormat  string
        ingressVerbose       bool
        ingressTimeout       time.Duration
)

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(ingressCmd)

        // Flags
        ingressCmd.Flags().BoolVar(&amp;ingressAll, "all", false, "Diagnose all ingress resources in namespace(s)")
        ingressCmd.Flags().BoolVar(&amp;ingressAllNamespaces, "all-namespaces", false, "Analyze ingress resources across all namespaces")
        ingressCmd.Flags().StringSliceVar(&amp;ingressChecks, "checks", []string{}, "Comma-separated list of checks to run (existence,config,backends,endpoints,ssl)")
        ingressCmd.Flags().StringVarP(&amp;ingressOutputFormat, "output", "o", "table", "Output format (table, json, yaml)")
        ingressCmd.Flags().BoolVarP(&amp;ingressVerbose, "verbose", "v", false, "Enable verbose output")
        ingressCmd.Flags().DurationVar(&amp;ingressTimeout, "timeout", 30*time.Second, "Timeout for diagnosis operations")

        // Add aliases for convenience
        ingressCmd.Aliases = []string{"ing", "ingresses"}
}</span>

func runIngressDiagnosis(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Get global flags
        kubeconfig, _ := cmd.Flags().GetString("kubeconfig")
        namespace, _ := cmd.Flags().GetString("namespace")

        // Set defaults
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        // Create context with timeout
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), ingressTimeout)
        defer cancel()

        // Initialize Kubernetes client
        kubeClient, err := client.NewKubernetesClient(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Kubernetes client: %w", err)
        }</span>

        // Initialize output manager
        <span class="cov0" title="0">outputMgr := output.NewOutputManager(ingressOutputFormat, ingressVerbose)

        // Initialize ingress diagnostic
        ingressDiag := ingress.NewIngressDiagnostic(kubeClient, outputMgr)

        // Prepare diagnostic configuration
        config := ingress.DiagnosticConfig{
                Namespace:     namespace,
                AllNamespaces: ingressAllNamespaces,
                All:           ingressAll,
                Checks:        ingressChecks,
                Timeout:       ingressTimeout,
        }

        // Handle specific ingress vs. all ingresses
        if len(args) == 1 </span><span class="cov0" title="0">{
                // Diagnose specific ingress
                ingressName := args[0]
                config.IngressName = ingressName

                report, err := ingressDiag.DiagnoseIngress(ctx, ingressName, config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to diagnose ingress %s: %w", ingressName, err)
                }</span>

                // Print the report
                <span class="cov0" title="0">if err := outputMgr.PrintReport(report); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to print report: %w", err)
                }</span>

        } else<span class="cov0" title="0"> if ingressAll </span><span class="cov0" title="0">{
                // Diagnose all ingresses
                reports, err := ingressDiag.DiagnoseAllIngresses(ctx, config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to diagnose ingresses: %w", err)
                }</span>

                // Print each report
                <span class="cov0" title="0">for _, report := range reports </span><span class="cov0" title="0">{
                        if err := outputMgr.PrintReport(report); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to print report: %w", err)
                        }</span>
                        // Add separator between reports for table format
                        <span class="cov0" title="0">if ingressOutputFormat == "table" &amp;&amp; len(reports) &gt; 1 </span><span class="cov0" title="0">{
                                fmt.Println(output.ColorDim + strings.Repeat("‚îÄ", 80) + output.ColorReset)
                        }</span>
                }

                // Print summary if multiple ingresses were analyzed
                <span class="cov0" title="0">if len(reports) &gt; 1 </span><span class="cov0" title="0">{
                        printIngressSummary(reports)
                }</span>

        } else<span class="cov0" title="0"> {
                return fmt.Errorf("please specify an ingress name or use --all flag")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// printIngressSummary prints a summary of multiple ingress diagnoses
func printIngressSummary(reports []*output.DiagnosticReport) <span class="cov0" title="0">{
        total := len(reports)
        var totalChecks, passed, failed, warnings, skipped int

        for _, report := range reports </span><span class="cov0" title="0">{
                totalChecks += report.Summary.Total
                passed += report.Summary.Passed
                failed += report.Summary.Failed
                warnings += report.Summary.Warnings
                skipped += report.Summary.Skipped
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nüìä Ingress Diagnostics Summary:\n")
        fmt.Printf("   Total Ingresses: %d\n", total)
        fmt.Printf("   Total Checks: %d\n", totalChecks)
        fmt.Printf("   ‚úÖ Passed: %d\n", passed)
        fmt.Printf("   ‚ùå Failed: %d\n", failed)
        fmt.Printf("   ‚ö†Ô∏è  Warnings: %d\n", warnings)
        fmt.Printf("   ‚è≠Ô∏è  Skipped: %d\n", skipped)

        // Calculate health percentage
        if totalChecks &gt; 0 </span><span class="cov0" title="0">{
                healthPercent := float64(passed) / float64(totalChecks) * 100
                fmt.Printf("   Health Score: %.1f%%\n", healthPercent)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "context"
        "fmt"
        "time"

        "github.com/spf13/cobra"

        "kdebug/internal/client"
        "kdebug/internal/output"
        "kdebug/pkg/pod"
)

var podCmd = &amp;cobra.Command{
        Use:   "pod [pod-name] [flags]",
        Short: "Diagnose pod-level issues and provide remediation suggestions",
        Long: `Diagnose common pod-level issues in Kubernetes clusters including:

‚Ä¢ Pending pods (scheduling constraints, resource limits, node taints)
‚Ä¢ Image pull errors and registry connectivity problems  
‚Ä¢ CrashLoopBackOff detection with log analysis and hints
‚Ä¢ RBAC permission validation for pods and service accounts
‚Ä¢ Init container failures and misconfigurations
‚Ä¢ Resource constraints and quality of service issues

This command analyzes pod status, events, logs, and related resources to identify
root causes and provide actionable remediation suggestions.`,
        Example: `  # Diagnose a specific pod
  kdebug pod myapp-deployment-7d4b8c6f9-x8k2l

  # Diagnose pod in specific namespace
  kdebug pod myapp-pod --namespace production

  # Diagnose all pods in a namespace
  kdebug pod --all --namespace default

  # Export detailed analysis to JSON
  kdebug pod myapp-pod --output json --verbose

  # Focus on specific diagnostic areas
  kdebug pod myapp-pod --checks=scheduling,images,rbac

  # Include detailed log analysis for crashed pods
  kdebug pod myapp-pod --include-logs --log-lines 50`,
        RunE: runPodDiagnostics,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(podCmd)

        // Pod-specific flags
        podCmd.Flags().BoolP("all", "a", false, "Diagnose all pods in the specified namespace")
        podCmd.Flags().StringSlice("checks", []string{}, "Comma-separated list of checks to run (scheduling,images,rbac,logs,init-containers)")
        podCmd.Flags().Bool("include-logs", false, "Include container log analysis for failed pods")
        podCmd.Flags().Int("log-lines", 20, "Number of recent log lines to analyze (when --include-logs is enabled)")
        podCmd.Flags().Duration("timeout", 30*time.Second, "Timeout for pod diagnostics")
        podCmd.Flags().Bool("watch", false, "Watch pod status and re-run diagnostics on changes")
        podCmd.Flags().StringSlice("containers", []string{}, "Specific containers to analyze (default: all containers)")
}</span>

func runPodDiagnostics(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Parse flags
        allPods, _ := cmd.Flags().GetBool("all")
        checks, _ := cmd.Flags().GetStringSlice("checks")
        includeLogs, _ := cmd.Flags().GetBool("include-logs")
        logLines, _ := cmd.Flags().GetInt("log-lines")
        timeout, _ := cmd.Flags().GetDuration("timeout")
        watch, _ := cmd.Flags().GetBool("watch")
        containers, _ := cmd.Flags().GetStringSlice("containers")

        // Get global flags
        outputFormat, _ := cmd.Flags().GetString("outputFormat")
        verbose, _ := cmd.Flags().GetBool("verbose")
        kubeconfig, _ := cmd.Flags().GetString("kubeconfig")
        namespace, _ := cmd.Flags().GetString("namespace")

        // Validate arguments
        if !allPods &amp;&amp; len(args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("pod name is required when --all is not specified")
        }</span>

        <span class="cov0" title="0">if allPods &amp;&amp; len(args) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot specify pod name when using --all flag")
        }</span>

        // Initialize dependencies
        <span class="cov0" title="0">outputManager := output.NewOutputManager(outputFormat, verbose)
        k8sClient, err := client.NewKubernetesClient(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                outputManager.PrintError("Failed to initialize Kubernetes client", err)
                return fmt.Errorf("failed to create Kubernetes client: %w", err)
        }</span>

        // Test connectivity
        <span class="cov0" title="0">ctx := context.Background()
        if err := k8sClient.TestConnection(ctx); err != nil </span><span class="cov0" title="0">{
                outputManager.PrintError("Kubernetes connectivity check failed", err)
                return err
        }</span>

        <span class="cov0" title="0">outputManager.PrintInfo("Initializing pod diagnostics...")

        // Create diagnostic configuration
        config := pod.DiagnosticConfig{
                Namespace:   namespace,
                Checks:      checks,
                IncludeLogs: includeLogs,
                LogLines:    logLines,
                Timeout:     timeout,
                Containers:  containers,
        }

        // Initialize pod diagnostic
        diagnostic := pod.NewPodDiagnostic(k8sClient, outputManager)

        var report *output.DiagnosticReport
        var podName string

        if allPods </span><span class="cov0" title="0">{
                outputManager.PrintInfo(fmt.Sprintf("Analyzing all pods in namespace '%s'...", namespace))
                report, err = diagnostic.DiagnoseAllPods(config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to diagnose pods: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                podName = args[0]
                outputManager.PrintInfo(fmt.Sprintf("Analyzing pod '%s' in namespace '%s'...", podName, namespace))

                if watch </span><span class="cov0" title="0">{
                        return diagnostic.WatchPod(podName, config)
                }</span>

                <span class="cov0" title="0">report, err = diagnostic.DiagnosePod(podName, config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to diagnose pod '%s': %w", podName, err)
                }</span>
        }

        // Output results
        <span class="cov0" title="0">if err := outputManager.PrintReport(report); err != nil </span><span class="cov0" title="0">{
                outputManager.PrintWarning(fmt.Sprintf("Failed to print report: %v", err))
        }</span>

        // Don't return error for diagnostic findings - just print summary
        // This allows the command to exit cleanly while still reporting issues
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright ¬© 2025 NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cmd

import (
        "os"

        "github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "kdebug",
        Short: "A CLI tool that automatically diagnoses common Kubernetes issues",
        Long: `kdebug is a diagnostic tool for Kubernetes clusters that automatically
identifies common issues and provides actionable suggestions.

Think of it as a "doctor" for Kubernetes clusters (like 'brew doctor', but for K8s).
Instead of manually digging through kubectl describe outputs and events, kdebug 
runs a series of checks and gives clear guidance on what's wrong and how to fix it.

Examples:
  kdebug cluster                           # Run cluster-wide health checks
  kdebug pod myapp-123 -n production      # Debug a specific pod
  kdebug service myservice                 # Check service and endpoints
  kdebug ingress my-ingress                # Diagnose ingress routing issues
  kdebug dns                               # Test DNS resolution`,
        Version: "1.0.1",
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

var (
        // Global flags
        kubeconfig   string
        namespace    string
        outputFormat string
        verbose      bool
)

func init() <span class="cov0" title="0">{
        // Global persistent flags that apply to all commands
        rootCmd.PersistentFlags().StringVar(&amp;kubeconfig, "kubeconfig", "", "path to kubeconfig file (defaults to $HOME/.kube/config)")
        rootCmd.PersistentFlags().StringVarP(&amp;namespace, "namespace", "n", "default", "Kubernetes namespace")
        rootCmd.PersistentFlags().StringVarP(&amp;outputFormat, "output", "o", "table", "output format: table, json, yaml")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "verbose output for debugging")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "context"
        "fmt"
        "time"

        "github.com/spf13/cobra"

        "kdebug/internal/client"
        "kdebug/internal/output"
        "kdebug/pkg/service"
)

var serviceCmd = &amp;cobra.Command{
        Use:   "service [service-name] [flags]",
        Short: "Diagnose service-level issues and validate connectivity",
        Long: `Diagnose common service-level issues in Kubernetes clusters including:

‚Ä¢ Service configuration validation (ports, selectors, service types)
‚Ä¢ Endpoint health and backend pod availability
‚Ä¢ Service selector matching with available pods
‚Ä¢ DNS resolution for service names within the cluster
‚Ä¢ Load balancing and traffic distribution issues
‚Ä¢ Connectivity validation between services and pods

This command analyzes service configuration, endpoints, DNS resolution, and related
resources to identify root causes and provide actionable remediation suggestions.`,
        Example: `  # Diagnose a specific service
  kdebug service frontend --namespace production

  # Check all services in namespace
  kdebug service --all --namespace default

  # Include DNS resolution testing
  kdebug service api-gateway --test-dns

  # Check services across all namespaces
  kdebug service --all-namespaces`,
        RunE: runServiceDiagnostics,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(serviceCmd)

        // Service-specific flags
        serviceCmd.Flags().BoolP("all", "a", false, "Diagnose all services in the specified namespace")
        serviceCmd.Flags().StringSlice("checks", []string{}, "Comma-separated list of checks to run (config,selector,endpoints,ports)")
        serviceCmd.Flags().Bool("test-dns", false, "Include DNS resolution testing for the service")
        serviceCmd.Flags().Bool("all-namespaces", false, "Check services across all namespaces")
        serviceCmd.Flags().Duration("timeout", 30*time.Second, "Timeout for service diagnostics")
}</span>

func runServiceDiagnostics(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Parse flags
        allServices, _ := cmd.Flags().GetBool("all")
        checks, _ := cmd.Flags().GetStringSlice("checks")
        testDNS, _ := cmd.Flags().GetBool("test-dns")
        allNamespaces, _ := cmd.Flags().GetBool("all-namespaces")
        timeout, _ := cmd.Flags().GetDuration("timeout")

        // Get global flags
        outputFormat, _ := cmd.Flags().GetString("outputFormat")
        verbose, _ := cmd.Flags().GetBool("verbose")
        kubeconfig, _ := cmd.Flags().GetString("kubeconfig")
        namespace, _ := cmd.Flags().GetString("namespace")

        // Validate arguments
        if !allServices &amp;&amp; !allNamespaces &amp;&amp; len(args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("service name is required when --all and --all-namespaces are not specified")
        }</span>

        <span class="cov0" title="0">if len(args) &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("only one service name is supported")
        }</span>

        // Create context with timeout
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // Initialize Kubernetes client
        kubeClient, err := client.NewKubernetesClient(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Kubernetes client: %w", err)
        }</span>

        // Initialize output manager
        <span class="cov0" title="0">outputMgr := output.NewOutputManager(outputFormat, verbose)

        // Initialize service diagnostic
        serviceDiag := service.NewServiceDiagnostic(kubeClient, outputMgr)

        // Create diagnostic configuration
        config := service.DiagnosticConfig{
                Namespace:     namespace,
                Checks:        checks,
                TestDNS:       testDNS,
                AllNamespaces: allNamespaces,
                Timeout:       timeout,
                Verbose:       verbose,
        }

        // Run diagnostics
        if allServices || allNamespaces </span><span class="cov0" title="0">{
                // Diagnose all services
                reports, err := serviceDiag.DiagnoseAllServices(ctx, config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to diagnose services: %w", err)
                }</span>

                // Print results
                <span class="cov0" title="0">for _, report := range reports </span><span class="cov0" title="0">{
                        if err := outputMgr.PrintReport(report); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to print report: %w", err)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span> // Add spacing between reports
                }

                // Print summary
                <span class="cov0" title="0">if len(reports) &gt; 0 </span><span class="cov0" title="0">{
                        printServicesSummary(outputMgr, reports)
                }</span>

        } else<span class="cov0" title="0"> {
                // Diagnose specific service
                serviceName := args[0]
                report, err := serviceDiag.DiagnoseService(ctx, serviceName, config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to diagnose service %s: %w", serviceName, err)
                }</span>

                // Print results
                <span class="cov0" title="0">if err := outputMgr.PrintReport(report); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to print report: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// printServicesSummary prints a summary of all service diagnostic results.
func printServicesSummary(outputMgr *output.OutputManager, reports []*output.DiagnosticReport) <span class="cov0" title="0">{
        if outputMgr.Format != output.FormatTable </span><span class="cov0" title="0">{
                return // Only print summary for table format
        }</span>

        <span class="cov0" title="0">totalServices := len(reports)
        healthyServices := 0
        unhealthyServices := 0
        warningServices := 0

        for _, report := range reports </span><span class="cov0" title="0">{
                if report.Summary.Failed &gt; 0 </span><span class="cov0" title="0">{
                        unhealthyServices++
                }</span> else<span class="cov0" title="0"> if report.Summary.Warnings &gt; 0 </span><span class="cov0" title="0">{
                        warningServices++
                }</span> else<span class="cov0" title="0"> {
                        healthyServices++
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nüìä Service Health Summary:\n")
        fmt.Printf("   Total Services: %d\n", totalServices)
        fmt.Printf("   ‚úÖ Healthy: %d\n", healthyServices)
        fmt.Printf("   ‚ö†Ô∏è  Warnings: %d\n", warningServices)
        fmt.Printf("   ‚ùå Unhealthy: %d\n", unhealthyServices)

        if unhealthyServices &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nüéØ Priority Actions:\n")
                fmt.Printf("   1. Investigate services with failed checks\n")
                fmt.Printf("   2. Verify pod health and readiness for services with endpoint issues\n")
                fmt.Printf("   3. Check service selectors match pod labels\n")
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package client

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/homedir"
)

// KubernetesClient wraps the Kubernetes clientset with additional metadata
type KubernetesClient struct {
        Clientset *kubernetes.Clientset
        Config    *rest.Config
        Context   string
}

// NewKubernetesClient creates a new Kubernetes client
func NewKubernetesClient(kubeconfig string) (*KubernetesClient, error) <span class="cov8" title="1">{
        var config *rest.Config

        var err error

        if kubeconfig == "" </span><span class="cov8" title="1">{
                // Try in-cluster config first
                config, err = rest.InClusterConfig()
                if err != nil </span><span class="cov8" title="1">{
                        // Fall back to kubeconfig file using proper loading rules
                        // This handles KUBECONFIG env var and default paths correctly
                        loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
                        configOverrides := &amp;clientcmd.ConfigOverrides{}
                        clientConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
                        config, err = clientConfig.ClientConfig()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to load kubeconfig: %w", err)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // Load config from specific kubeconfig file
                config, err = clientcmd.BuildConfigFromFlags("", kubeconfig)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to load kubeconfig: %w", err)
                }</span>
        }

        // Create clientset
        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Kubernetes client: %w", err)
        }</span>

        // Get current context
        <span class="cov0" title="0">context := getCurrentContextFromConfig(config, kubeconfig)

        return &amp;KubernetesClient{
                Clientset: clientset,
                Config:    config,
                Context:   context,
        }, nil</span>
}

// TestConnection tests the connection to the Kubernetes cluster
func (k *KubernetesClient) TestConnection(ctx context.Context) error <span class="cov0" title="0">{
        _, err := k.Clientset.Discovery().ServerVersion()
        if err != nil </span><span class="cov0" title="0">{
                // Provide more helpful error messages for common issues
                errMsg := err.Error()
                if strings.Contains(errMsg, "the server has asked for the client to provide credentials") </span><span class="cov0" title="0">{
                        return fmt.Errorf("authentication failed - please check your credentials:\n"+
                                "  ‚Ä¢ For EKS: run 'aws eks update-kubeconfig --region &lt;region&gt; --name &lt;cluster-name&gt;'\n"+
                                "  ‚Ä¢ Ensure AWS credentials are valid: 'aws sts get-caller-identity'\n"+
                                "  ‚Ä¢ Check kubeconfig: 'kubectl cluster-info'\n"+
                                "Original error: %w", err)
                }</span>

                <span class="cov0" title="0">if strings.Contains(errMsg, "no such host") || strings.Contains(errMsg, "connection refused") </span><span class="cov0" title="0">{
                        return fmt.Errorf("cluster unreachable - please check network connectivity:\n"+
                                "  ‚Ä¢ Verify cluster is running\n"+
                                "  ‚Ä¢ Check kubeconfig server URL\n"+
                                "  ‚Ä¢ Ensure network access to cluster\n"+
                                "Original error: %w", err)
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("failed to connect to Kubernetes cluster: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetClusterInfo returns basic cluster information
func (k *KubernetesClient) GetClusterInfo(ctx context.Context) (map[string]string, error) <span class="cov0" title="0">{
        version, err := k.Clientset.Discovery().ServerVersion()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get server version: %w", err)
        }</span>

        <span class="cov0" title="0">info := map[string]string{
                "context":    k.Context,
                "server":     k.Config.Host,
                "version":    version.String(),
                "gitVersion": version.GitVersion,
                "platform":   version.Platform,
        }

        return info, nil</span>
}

// getDefaultKubeconfigPath returns the default kubeconfig path
func getDefaultKubeconfigPath() string <span class="cov8" title="1">{
        if home := homedir.HomeDir(); home != "" </span><span class="cov8" title="1">{
                return filepath.Join(home, ".kube", "config")
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// getCurrentContextFromConfig returns the current context from the loaded config
func getCurrentContextFromConfig(_ *rest.Config, kubeconfig string) string <span class="cov0" title="0">{
        // If we have a specific kubeconfig file, try to get context from it
        if kubeconfig != "" </span><span class="cov0" title="0">{
                if rawConfig, err := clientcmd.LoadFromFile(kubeconfig); err == nil </span><span class="cov0" title="0">{
                        return rawConfig.CurrentContext
                }</span>
        }

        // Fall back to getting context using default loading rules
        <span class="cov0" title="0">loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
        configOverrides := &amp;clientcmd.ConfigOverrides{}
        clientConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
        if rawConfig, err := clientConfig.RawConfig(); err == nil </span><span class="cov0" title="0">{
                return rawConfig.CurrentContext
        }</span>

        <span class="cov0" title="0">return "unknown"</span>
}

// getCurrentContext returns the current context from kubeconfig
func getCurrentContext(kubeconfig string) (string, error) <span class="cov8" title="1">{
        if kubeconfig == "" </span><span class="cov8" title="1">{
                kubeconfig = getDefaultKubeconfigPath()
        }</span>

        <span class="cov8" title="1">if _, err := os.Stat(kubeconfig); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov0" title="0">config, err := clientcmd.LoadFromFile(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return config.CurrentContext, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package output

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "gopkg.in/yaml.v3"
)

// ANSI color codes for terminal output
const (
        ColorReset  = "\033[0m"
        ColorRed    = "\033[31m"
        ColorGreen  = "\033[32m"
        ColorYellow = "\033[33m"
        ColorBlue   = "\033[34m"
        ColorPurple = "\033[35m"
        ColorCyan   = "\033[36m"
        ColorWhite  = "\033[37m"
        ColorBold   = "\033[1m"
        ColorDim    = "\033[2m"
)

// Terminal formatting helpers
func colorize(text, color string) string <span class="cov8" title="1">{
        return color + text + ColorReset
}</span>

func bold(text string) string <span class="cov8" title="1">{
        return ColorBold + text + ColorReset
}</span>

func dim(text string) string <span class="cov8" title="1">{
        return ColorDim + text + ColorReset
}</span>

// OutputFormat represents the supported output formats
type OutputFormat string

const (
        FormatTable OutputFormat = "table"
        FormatJSON  OutputFormat = "json"
        FormatYAML  OutputFormat = "yaml"
)

// CheckResult represents a single diagnostic check result
type CheckResult struct {
        Name       string            `json:"name" yaml:"name"`
        Status     CheckStatus       `json:"status" yaml:"status"`
        Message    string            `json:"message" yaml:"message"`
        Suggestion string            `json:"suggestion,omitempty" yaml:"suggestion,omitempty"`
        Details    map[string]string `json:"details,omitempty" yaml:"details,omitempty"`
        Error      string            `json:"error,omitempty" yaml:"error,omitempty"`
}

// CheckStatus represents the status of a check
type CheckStatus string

const (
        StatusPassed  CheckStatus = "PASSED"
        StatusFailed  CheckStatus = "FAILED"
        StatusWarning CheckStatus = "WARNING"
        StatusSkipped CheckStatus = "SKIPPED"
)

// DiagnosticReport represents a complete diagnostic report
type DiagnosticReport struct {
        ClusterInfo map[string]string      `json:"cluster_info" yaml:"cluster_info"`
        Metadata    map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty"`
        Checks      []CheckResult          `json:"checks" yaml:"checks"`
        Target      string                 `json:"target" yaml:"target"`
        Timestamp   string                 `json:"timestamp" yaml:"timestamp"`
        Summary     Summary                `json:"summary" yaml:"summary"`
}

// Summary provides a summary of check results
type Summary struct {
        Total    int `json:"total" yaml:"total"`
        Passed   int `json:"passed" yaml:"passed"`
        Failed   int `json:"failed" yaml:"failed"`
        Warnings int `json:"warnings" yaml:"warnings"`
        Skipped  int `json:"skipped" yaml:"skipped"`
}

// OutputManager handles formatting and outputting results
type OutputManager struct {
        Format  OutputFormat
        Verbose bool
}

// NewOutputManager creates a new output manager
func NewOutputManager(format string, verbose bool) *OutputManager <span class="cov8" title="1">{
        outputFormat := OutputFormat(strings.ToLower(format))

        // Validate format and default to table if invalid
        switch outputFormat </span>{
        case FormatTable, FormatJSON, FormatYAML:<span class="cov8" title="1"></span>
                // Valid format
        default:<span class="cov8" title="1">
                outputFormat = FormatTable</span>
        }

        <span class="cov8" title="1">return &amp;OutputManager{
                Format:  outputFormat,
                Verbose: verbose,
        }</span>
}

// PrintReport prints the diagnostic report in the specified format
func (o *OutputManager) PrintReport(report *DiagnosticReport) error <span class="cov8" title="1">{
        switch o.Format </span>{
        case FormatJSON:<span class="cov8" title="1">
                return o.printJSON(report)</span>
        case FormatYAML:<span class="cov8" title="1">
                return o.printYAML(report)</span>
        case FormatTable:<span class="cov8" title="1">
                return o.printTable(report)</span>
        default:<span class="cov0" title="0">
                return o.printTable(report)</span>
        }
}

// printJSON prints the report as JSON
func (o *OutputManager) printJSON(report *DiagnosticReport) error <span class="cov8" title="1">{
        encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(report)
}</span>

// printYAML prints the report as YAML
func (o *OutputManager) printYAML(report *DiagnosticReport) error <span class="cov8" title="1">{
        encoder := yaml.NewEncoder(os.Stdout)
        defer func() </span><span class="cov8" title="1">{
                if err := encoder.Close(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error closing YAML encoder: %v\n", err)
                }</span>
        }()
        <span class="cov8" title="1">return encoder.Encode(report)</span>
}

// printTable prints the report as a pytest-style formatted output
func (o *OutputManager) printTable(report *DiagnosticReport) error <span class="cov8" title="1">{
        // Print clean header
        fmt.Printf("%s\n", bold("KDEBUG KUBERNETES DIAGNOSTIC REPORT"))
        fmt.Printf("Target: %s | Timestamp: %s\n", report.Target, report.Timestamp)

        // Print metadata if available
        if len(report.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Resource: %v | Status: %v\n",
                        report.Metadata["pod_name"],
                        report.Metadata["status"])
        }</span>

        <span class="cov8" title="1">fmt.Println()

        // Print checks in pytest style
        fmt.Printf("%s\n", bold("Diagnostic Checks:"))
        fmt.Println()

        for _, check := range report.Checks </span><span class="cov8" title="1">{
                status := o.formatStatusClean(check.Status)
                fmt.Printf("%-50s %s\n", check.Name, status)

                // Print detailed information if verbose and there are issues
                if o.Verbose &amp;&amp; (check.Status == StatusFailed || check.Status == StatusWarning) </span><span class="cov8" title="1">{
                        if check.Message != "" </span><span class="cov8" title="1">{
                                fmt.Printf("    %s\n", dim("Message: "+check.Message))
                        }</span>
                        <span class="cov8" title="1">if check.Suggestion != "" </span><span class="cov8" title="1">{
                                fmt.Printf("    %s\n", dim("Suggestion: "+check.Suggestion))
                        }</span>
                        <span class="cov8" title="1">if len(check.Details) &gt; 0 </span><span class="cov8" title="1">{
                                for key, value := range check.Details </span><span class="cov8" title="1">{
                                        fmt.Printf("    %s\n", dim(fmt.Sprintf("%s: %s", key, value)))
                                }</span>
                        }
                        <span class="cov8" title="1">fmt.Println()</span>
                }
        }

        // Print clean summary like pytest
        <span class="cov8" title="1">fmt.Println()
        fmt.Printf("%s\n", bold("Summary:"))

        // Count and categorize results
        passed := report.Summary.Passed
        failed := report.Summary.Failed
        warnings := report.Summary.Warnings
        skipped := report.Summary.Skipped

        // Print summary line with colors
        summaryParts := []string{}
        if passed &gt; 0 </span><span class="cov8" title="1">{
                summaryParts = append(summaryParts, colorize(fmt.Sprintf("%d passed", passed), ColorGreen))
        }</span>
        <span class="cov8" title="1">if failed &gt; 0 </span><span class="cov8" title="1">{
                summaryParts = append(summaryParts, colorize(fmt.Sprintf("%d failed", failed), ColorRed))
        }</span>
        <span class="cov8" title="1">if warnings &gt; 0 </span><span class="cov8" title="1">{
                summaryParts = append(summaryParts, colorize(fmt.Sprintf("%d warnings", warnings), ColorYellow))
        }</span>
        <span class="cov8" title="1">if skipped &gt; 0 </span><span class="cov0" title="0">{
                summaryParts = append(summaryParts, colorize(fmt.Sprintf("%d skipped", skipped), ColorCyan))
        }</span>

        <span class="cov8" title="1">fmt.Printf("%s in total\n", strings.Join(summaryParts, ", "))

        // Print failed and warning details if not verbose
        if !o.Verbose &amp;&amp; (failed &gt; 0 || warnings &gt; 0) </span><span class="cov8" title="1">{
                fmt.Println()
                fmt.Printf("%s\n", bold("Issues found:"))

                for _, check := range report.Checks </span><span class="cov8" title="1">{
                        if check.Status == StatusFailed </span><span class="cov8" title="1">{
                                fmt.Printf("  %s %s\n", colorize("FAILED", ColorRed), check.Name)
                                if check.Message != "" </span><span class="cov8" title="1">{
                                        fmt.Printf("    %s\n", dim(check.Message))
                                }</span>
                        }
                }

                <span class="cov8" title="1">for _, check := range report.Checks </span><span class="cov8" title="1">{
                        if check.Status == StatusWarning </span><span class="cov8" title="1">{
                                fmt.Printf("  %s %s\n", colorize("WARNING", ColorYellow), check.Name)
                                if check.Message != "" </span><span class="cov8" title="1">{
                                        fmt.Printf("    %s\n", dim(check.Message))
                                }</span>
                        }
                }

                <span class="cov8" title="1">fmt.Println()
                fmt.Printf("%s\n", dim("Run with --verbose for detailed information"))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// formatStatusClean returns a clean pytest-style status indicator
func (o *OutputManager) formatStatusClean(status CheckStatus) string <span class="cov8" title="1">{
        switch status </span>{
        case StatusPassed:<span class="cov8" title="1">
                return colorize("PASSED", ColorGreen)</span>
        case StatusFailed:<span class="cov8" title="1">
                return colorize("FAILED", ColorRed)</span>
        case StatusWarning:<span class="cov8" title="1">
                return colorize("WARNING", ColorYellow)</span>
        case StatusSkipped:<span class="cov0" title="0">
                return colorize("SKIPPED", ColorCyan)</span>
        default:<span class="cov0" title="0">
                return colorize("UNKNOWN", ColorWhite)</span>
        }
}

// formatStatus returns a colored status indicator (legacy function for compatibility)
func (o *OutputManager) formatStatus(status CheckStatus) string <span class="cov8" title="1">{
        switch status </span>{
        case StatusPassed:<span class="cov8" title="1">
                return "‚úÖ"</span>
        case StatusFailed:<span class="cov8" title="1">
                return "‚ùå"</span>
        case StatusWarning:<span class="cov8" title="1">
                return "‚ö†Ô∏è"</span>
        case StatusSkipped:<span class="cov8" title="1">
                return "‚è≠Ô∏è"</span>
        default:<span class="cov8" title="1">
                return "‚ùì"</span>
        }
}

// PrintError prints an error message
func (o *OutputManager) PrintError(message string, err error) <span class="cov8" title="1">{
        fmt.Fprintf(os.Stderr, "%s %s\n", colorize("ERROR:", ColorRed), message)

        if err != nil </span><span class="cov0" title="0">{
                if o.Verbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "   Details: %v\n", err)
                }</span>
        }
}

// PrintWarning prints a warning message
func (o *OutputManager) PrintWarning(message string) <span class="cov8" title="1">{
        // For structured output formats, write to stderr to avoid contaminating the output
        if o.Format == FormatJSON || o.Format == FormatYAML </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "%s %s\n", colorize("WARNING:", ColorYellow), message)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("%s %s\n", colorize("WARNING:", ColorYellow), message)
        }</span>
}

// PrintInfo prints an informational message
func (o *OutputManager) PrintInfo(message string) <span class="cov8" title="1">{
        // For structured output formats, write to stderr to avoid contaminating the output
        if o.Format == FormatJSON || o.Format == FormatYAML </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "%s %s\n", colorize("INFO:", ColorCyan), message)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("%s %s\n", colorize("INFO:", ColorCyan), message)
        }</span>
}

// PrintSuccess prints a success message
func (o *OutputManager) PrintSuccess(message string) <span class="cov8" title="1">{
        // For structured output formats, write to stderr to avoid contaminating the output
        if o.Format == FormatJSON || o.Format == FormatYAML </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "%s %s\n", colorize("SUCCESS:", ColorGreen), message)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("%s %s\n", colorize("SUCCESS:", ColorGreen), message)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright ¬© 2025 NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package main

import "kdebug/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package cluster

import (
        "context"
        "fmt"
        "time"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "kdebug/internal/client"
        "kdebug/internal/output"
)

// ClusterDiagnostic handles cluster-level health checks
type ClusterDiagnostic struct {
        client *client.KubernetesClient
        output *output.OutputManager
}

// NewClusterDiagnostic creates a new cluster diagnostic
func NewClusterDiagnostic(k8sClient *client.KubernetesClient, outputMgr *output.OutputManager) *ClusterDiagnostic <span class="cov8" title="1">{
        return &amp;ClusterDiagnostic{
                client: k8sClient,
                output: outputMgr,
        }
}</span>

// RunDiagnostics runs all cluster-level diagnostic checks
func (c *ClusterDiagnostic) RunDiagnostics(ctx context.Context) (*output.DiagnosticReport, error) <span class="cov0" title="0">{
        // Get cluster info
        clusterInfo, err := c.client.GetClusterInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cluster info: %w", err)
        }</span>

        // Initialize report
        <span class="cov0" title="0">report := &amp;output.DiagnosticReport{
                Target:      "cluster",
                Timestamp:   time.Now().Format(time.RFC3339),
                ClusterInfo: clusterInfo,
                Checks:      []output.CheckResult{},
                Metadata:    make(map[string]interface{}),
        }

        // Run connectivity check
        connectivityResult := c.checkConnectivity(ctx)
        report.Checks = append(report.Checks, connectivityResult)

        // Run node health checks
        nodeResults := c.checkNodeHealth(ctx)
        report.Checks = append(report.Checks, nodeResults...)

        // Run control plane checks
        controlPlaneResults := c.checkControlPlane(ctx)
        report.Checks = append(report.Checks, controlPlaneResults...)

        // Run DNS checks
        dnsResult := c.checkDNS(ctx)
        report.Checks = append(report.Checks, dnsResult)

        // Calculate summary
        report.Summary = c.calculateSummary(report.Checks)

        return report, nil</span>
}

// checkConnectivity tests basic connectivity to the Kubernetes API server
func (c *ClusterDiagnostic) checkConnectivity(ctx context.Context) output.CheckResult <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.TestConnection(ctx)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "API Server Connectivity",
                        Status:     output.StatusFailed,
                        Message:    "Failed to connect to Kubernetes API server",
                        Error:      err.Error(),
                        Suggestion: "Check your kubeconfig file and ensure the cluster is accessible",
                }
        }</span>

        <span class="cov0" title="0">details := map[string]string{
                "response_time": duration.String(),
                "server":        c.client.Config.Host,
        }

        message := fmt.Sprintf("Successfully connected to API server (response time: %v)", duration)
        if duration &gt; 5*time.Second </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "API Server Connectivity",
                        Status:     output.StatusWarning,
                        Message:    message + " - slow response",
                        Details:    details,
                        Suggestion: "API server response is slow, check network connectivity",
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "API Server Connectivity",
                Status:  output.StatusPassed,
                Message: message,
                Details: details,
        }</span>
}

// checkNodeHealth checks the health status of all nodes
func (c *ClusterDiagnostic) checkNodeHealth(ctx context.Context) []output.CheckResult <span class="cov0" title="0">{
        var results []output.CheckResult

        nodes, err := c.client.Clientset.CoreV1().Nodes().List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return []output.CheckResult{{
                        Name:       "Node Health",
                        Status:     output.StatusFailed,
                        Message:    "Failed to list cluster nodes",
                        Error:      err.Error(),
                        Suggestion: "Check RBAC permissions for node access",
                }}
        }</span>

        <span class="cov0" title="0">if len(nodes.Items) == 0 </span><span class="cov0" title="0">{
                return []output.CheckResult{{
                        Name:       "Node Health",
                        Status:     output.StatusFailed,
                        Message:    "No nodes found in cluster",
                        Suggestion: "Ensure cluster has at least one node",
                }}
        }</span>

        // Overall node summary
        <span class="cov0" title="0">totalNodes := len(nodes.Items)
        readyNodes := 0

        var problematicNodes []string

        // Check each node
        for i := range nodes.Items </span><span class="cov0" title="0">{
                node := &amp;nodes.Items[i]
                nodeReady := false

                var nodeIssues []string

                // Check node conditions
                for _, condition := range node.Status.Conditions </span><span class="cov0" title="0">{
                        switch condition.Type </span>{
                        case corev1.NodeReady:<span class="cov0" title="0">
                                if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        nodeReady = true
                                        readyNodes++
                                }</span> else<span class="cov0" title="0"> {
                                        nodeIssues = append(nodeIssues, "NotReady")
                                }</span>
                        case corev1.NodeMemoryPressure:<span class="cov0" title="0">
                                if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        nodeIssues = append(nodeIssues, "MemoryPressure")
                                }</span>
                        case corev1.NodeDiskPressure:<span class="cov0" title="0">
                                if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        nodeIssues = append(nodeIssues, "DiskPressure")
                                }</span>
                        case corev1.NodePIDPressure:<span class="cov0" title="0">
                                if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        nodeIssues = append(nodeIssues, "PIDPressure")
                                }</span>
                        case corev1.NodeNetworkUnavailable:<span class="cov0" title="0">
                                if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        nodeIssues = append(nodeIssues, "NetworkUnavailable")
                                }</span>
                        }
                }

                // Create individual node check if there are issues
                <span class="cov0" title="0">if len(nodeIssues) &gt; 0 </span><span class="cov0" title="0">{
                        problematicNodes = append(problematicNodes, node.Name)

                        status := output.StatusWarning
                        if !nodeReady </span><span class="cov0" title="0">{
                                status = output.StatusFailed
                        }</span>

                        <span class="cov0" title="0">results = append(results, output.CheckResult{
                                Name:    fmt.Sprintf("Node: %s", node.Name),
                                Status:  status,
                                Message: fmt.Sprintf("Node has issues: %v", nodeIssues),
                                Details: map[string]string{
                                        "node_name": node.Name,
                                        "issues":    fmt.Sprintf("%v", nodeIssues),
                                        "ready":     fmt.Sprintf("%t", nodeReady),
                                },
                                Suggestion: c.getNodeSuggestion(nodeIssues),
                        })</span>
                }
        }

        // Overall node health summary
        <span class="cov0" title="0">if readyNodes == totalNodes &amp;&amp; len(problematicNodes) == 0 </span><span class="cov0" title="0">{
                results = append([]output.CheckResult{{
                        Name:    "Node Health Overview",
                        Status:  output.StatusPassed,
                        Message: fmt.Sprintf("All %d nodes are healthy and ready", totalNodes),
                        Details: map[string]string{
                                "total_nodes": fmt.Sprintf("%d", totalNodes),
                                "ready_nodes": fmt.Sprintf("%d", readyNodes),
                        },
                }}, results...)
        }</span> else<span class="cov0" title="0"> {
                status := output.StatusWarning
                if readyNodes == 0 </span><span class="cov0" title="0">{
                        status = output.StatusFailed
                }</span>

                <span class="cov0" title="0">results = append([]output.CheckResult{{
                        Name:    "Node Health Overview",
                        Status:  status,
                        Message: fmt.Sprintf("%d/%d nodes ready, %d nodes with issues", readyNodes, totalNodes, len(problematicNodes)),
                        Details: map[string]string{
                                "total_nodes":       fmt.Sprintf("%d", totalNodes),
                                "ready_nodes":       fmt.Sprintf("%d", readyNodes),
                                "problematic_nodes": fmt.Sprintf("%v", problematicNodes),
                        },
                        Suggestion: "Check individual node issues below and address node problems",
                }}, results...)</span>
        }

        <span class="cov0" title="0">return results</span>
}

// checkControlPlane checks the health of control plane components
func (c *ClusterDiagnostic) checkControlPlane(ctx context.Context) []output.CheckResult <span class="cov0" title="0">{
        results := make([]output.CheckResult, 0, 8) // pre-allocate with capacity

        // Check if we can access system namespaces (indicates control plane access)
        systemPods, err := c.client.Clientset.CoreV1().Pods("kube-system").List(ctx, metav1.ListOptions{
                LabelSelector: "component in (etcd,kube-apiserver,kube-controller-manager,kube-scheduler)",
        })
        if err != nil </span><span class="cov0" title="0">{
                return []output.CheckResult{{
                        Name:       "Control Plane Health",
                        Status:     output.StatusWarning,
                        Message:    "Unable to access control plane components",
                        Error:      err.Error(),
                        Suggestion: "Check RBAC permissions for kube-system namespace access",
                }}
        }</span>

        <span class="cov0" title="0">if len(systemPods.Items) == 0 </span><span class="cov0" title="0">{
                return []output.CheckResult{{
                        Name:       "Control Plane Health",
                        Status:     output.StatusWarning,
                        Message:    "No control plane components found (might be managed cluster)",
                        Suggestion: "This might be a managed cluster (EKS, GKE, AKS) where control plane is managed",
                }}
        }</span>

        // Group pods by component
        <span class="cov0" title="0">components := make(map[string][]*corev1.Pod)
        for i := range systemPods.Items </span><span class="cov0" title="0">{
                pod := &amp;systemPods.Items[i]
                if component, exists := pod.Labels["component"]; exists </span><span class="cov0" title="0">{
                        components[component] = append(components[component], pod)
                }</span>
        }

        // Check each component
        <span class="cov0" title="0">allHealthy := true
        for component, pods := range components </span><span class="cov0" title="0">{
                runningPods := 0
                for _, pod := range pods </span><span class="cov0" title="0">{
                        if pod.Status.Phase == corev1.PodRunning </span><span class="cov0" title="0">{
                                runningPods++
                        }</span>
                }

                <span class="cov0" title="0">status := output.StatusPassed
                message := fmt.Sprintf("%s: %d/%d pods running", component, runningPods, len(pods))

                if runningPods == 0 </span><span class="cov0" title="0">{
                        status = output.StatusFailed
                        allHealthy = false
                        message = fmt.Sprintf("%s: no pods running", component)
                }</span> else<span class="cov0" title="0"> if runningPods &lt; len(pods) </span><span class="cov0" title="0">{
                        status = output.StatusWarning
                        allHealthy = false
                }</span>

                <span class="cov0" title="0">results = append(results, output.CheckResult{
                        Name:    fmt.Sprintf("Control Plane: %s", component),
                        Status:  status,
                        Message: message,
                        Details: map[string]string{
                                "component":    component,
                                "running_pods": fmt.Sprintf("%d", runningPods),
                                "total_pods":   fmt.Sprintf("%d", len(pods)),
                        },
                        Suggestion: c.getControlPlaneSuggestion(component, runningPods, len(pods)),
                })</span>
        }

        // Overall control plane summary
        <span class="cov0" title="0">overallStatus := output.StatusPassed
        summaryMessage := "Control plane components are healthy"

        if !allHealthy </span><span class="cov0" title="0">{
                overallStatus = output.StatusWarning
                summaryMessage = "Some control plane components have issues"
        }</span>

        <span class="cov0" title="0">results = append([]output.CheckResult{{
                Name:    "Control Plane Overview",
                Status:  overallStatus,
                Message: summaryMessage,
                Details: map[string]string{
                        "components_found": fmt.Sprintf("%d", len(components)),
                },
        }}, results...)

        return results</span>
}

// checkDNS performs basic DNS functionality check
func (c *ClusterDiagnostic) checkDNS(ctx context.Context) output.CheckResult <span class="cov0" title="0">{
        // Check CoreDNS/kube-dns pods
        dnsPods, err := c.client.Clientset.CoreV1().Pods("kube-system").List(ctx, metav1.ListOptions{
                LabelSelector: "k8s-app in (kube-dns,coredns)",
        })
        if err != nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "DNS Health",
                        Status:     output.StatusFailed,
                        Message:    "Failed to check DNS pods",
                        Error:      err.Error(),
                        Suggestion: "Check RBAC permissions for kube-system namespace",
                }
        }</span>

        <span class="cov0" title="0">if len(dnsPods.Items) == 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "DNS Health",
                        Status:     output.StatusFailed,
                        Message:    "No DNS pods found in kube-system namespace",
                        Suggestion: "Install CoreDNS or kube-dns for cluster DNS resolution",
                }
        }</span>

        <span class="cov0" title="0">runningDNSPods := 0

        for i := range dnsPods.Items </span><span class="cov0" title="0">{
                pod := &amp;dnsPods.Items[i]
                if pod.Status.Phase == corev1.PodRunning </span><span class="cov0" title="0">{
                        runningDNSPods++
                }</span>
        }

        <span class="cov0" title="0">details := map[string]string{
                "dns_pods_running": fmt.Sprintf("%d", runningDNSPods),
                "dns_pods_total":   fmt.Sprintf("%d", len(dnsPods.Items)),
        }

        if runningDNSPods == 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "DNS Health",
                        Status:     output.StatusFailed,
                        Message:    "No DNS pods are running",
                        Details:    details,
                        Suggestion: "Check DNS pod logs and restart DNS deployment",
                }
        }</span>

        <span class="cov0" title="0">if runningDNSPods &lt; len(dnsPods.Items) </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "DNS Health",
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("DNS partially functional: %d/%d pods running", runningDNSPods, len(dnsPods.Items)),
                        Details:    details,
                        Suggestion: "Some DNS pods are not running, check pod status and logs",
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "DNS Health",
                Status:  output.StatusPassed,
                Message: fmt.Sprintf("DNS is healthy: %d/%d pods running", runningDNSPods, len(dnsPods.Items)),
                Details: details,
        }</span>
}

// getNodeSuggestion returns appropriate suggestions for node issues
func (c *ClusterDiagnostic) getNodeSuggestion(issues []string) string <span class="cov8" title="1">{
        suggestions := []string{}

        for _, issue := range issues </span><span class="cov8" title="1">{
                switch issue </span>{
                case "NotReady":<span class="cov8" title="1">
                        suggestions = append(suggestions, "Check node status with 'kubectl describe node'")</span>
                case "MemoryPressure":<span class="cov8" title="1">
                        suggestions = append(suggestions, "Free up memory or add more nodes")</span>
                case "DiskPressure":<span class="cov8" title="1">
                        suggestions = append(suggestions, "Clean up disk space or add storage")</span>
                case "PIDPressure":<span class="cov0" title="0">
                        suggestions = append(suggestions, "Reduce running processes or increase PID limits")</span>
                case "NetworkUnavailable":<span class="cov0" title="0">
                        suggestions = append(suggestions, "Check network configuration and CNI")</span>
                }
        }

        <span class="cov8" title="1">if len(suggestions) &gt; 0 </span><span class="cov8" title="1">{
                return suggestions[0] // Return the first suggestion to avoid clutter
        }</span>
        <span class="cov8" title="1">return "Check node logs and status for more details"</span>
}

// getControlPlaneSuggestion returns suggestions for control plane issues
func (c *ClusterDiagnostic) getControlPlaneSuggestion(component string, running, total int) string <span class="cov8" title="1">{
        if running == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("Restart %s component or check its configuration", component)
        }</span>

        <span class="cov8" title="1">if running &lt; total </span><span class="cov8" title="1">{
                return fmt.Sprintf("Check %s pod logs for issues", component)
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// calculateSummary calculates the summary statistics for the checks
func (c *ClusterDiagnostic) calculateSummary(checks []output.CheckResult) output.Summary <span class="cov8" title="1">{
        summary := output.Summary{}

        for _, check := range checks </span><span class="cov8" title="1">{
                summary.Total++

                switch check.Status </span>{
                case output.StatusPassed:<span class="cov8" title="1">
                        summary.Passed++</span>
                case output.StatusFailed:<span class="cov8" title="1">
                        summary.Failed++</span>
                case output.StatusWarning:<span class="cov8" title="1">
                        summary.Warnings++</span>
                case output.StatusSkipped:<span class="cov8" title="1">
                        summary.Skipped++</span>
                }
        }

        <span class="cov8" title="1">return summary</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package ingress

import (
        "context"
        "fmt"
        "strings"
        "time"

        corev1 "k8s.io/api/core/v1"
        discoveryv1 "k8s.io/api/discovery/v1"
        networkingv1 "k8s.io/api/networking/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "kdebug/internal/client"
        "kdebug/internal/output"
)

// IngressDiagnostic handles ingress-related diagnostics
type IngressDiagnostic struct {
        client *client.KubernetesClient
        output *output.OutputManager
}

// DiagnosticConfig holds configuration for ingress diagnostics
type DiagnosticConfig struct {
        Namespace      string
        IngressName    string
        All            bool
        AllNamespaces  bool
        CheckSSL       bool
        TestBackends   bool
        TestDNS        bool
        CheckConflicts bool
        Controllers    bool
        Checks         []string
        Timeout        time.Duration
}

// IngressInfo contains information about an ingress resource
type IngressInfo struct {
        Ingress          *networkingv1.Ingress
        BackendServices  []*corev1.Service
        BackendEndpoints []*discoveryv1.EndpointSlice
        TLSSecrets       []*corev1.Secret
        LoadBalancerIP   string
}

// SummaryInfo provides a summary of ingress diagnostics
type SummaryInfo struct {
        Total         int
        Healthy       int
        Warning       int
        Critical      int
        Controllers   int
        Certificates  int
        BackendIssues int
}

// NewIngressDiagnostic creates a new ingress diagnostic instance
func NewIngressDiagnostic(kubeClient *client.KubernetesClient, outputMgr *output.OutputManager) *IngressDiagnostic <span class="cov8" title="1">{
        return &amp;IngressDiagnostic{
                client: kubeClient,
                output: outputMgr,
        }
}</span>

// DiagnoseIngress performs diagnostics on a single ingress resource
func (id *IngressDiagnostic) DiagnoseIngress(ctx context.Context, ingressName string, config DiagnosticConfig) (*output.DiagnosticReport, error) <span class="cov0" title="0">{
        id.output.PrintInfo(fmt.Sprintf("üîç Analyzing ingress: %s", ingressName))

        // Analyze the ingress resource
        ingressInfo, err := id.analyzeIngress(ctx, config.Namespace, ingressName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to analyze ingress %s: %w", ingressName, err)
        }</span>

        // Run diagnostic checks
        <span class="cov0" title="0">results := id.runIngressChecks(ctx, ingressInfo, config)

        // Create diagnostic report
        report := &amp;output.DiagnosticReport{
                Target:    fmt.Sprintf("ingress/%s", ingressName),
                Timestamp: time.Now().Format(time.RFC3339),
                Checks:    results,
                ClusterInfo: map[string]string{
                        "namespace": config.Namespace,
                },
                Metadata: map[string]interface{}{
                        "resourceType": "Ingress",
                        "resourceName": ingressName,
                        "namespace":    config.Namespace,
                },
        }

        // Calculate summary
        summary := output.Summary{Total: len(results)}
        for _, result := range results </span><span class="cov0" title="0">{
                switch result.Status </span>{
                case output.StatusPassed:<span class="cov0" title="0">
                        summary.Passed++</span>
                case output.StatusFailed:<span class="cov0" title="0">
                        summary.Failed++</span>
                case output.StatusWarning:<span class="cov0" title="0">
                        summary.Warnings++</span>
                case output.StatusSkipped:<span class="cov0" title="0">
                        summary.Skipped++</span>
                }
        }
        <span class="cov0" title="0">report.Summary = summary

        return report, nil</span>
}

// DiagnoseAllIngresses performs diagnostics on all ingress resources in specified namespaces
func (id *IngressDiagnostic) DiagnoseAllIngresses(ctx context.Context, config DiagnosticConfig) ([]*output.DiagnosticReport, error) <span class="cov0" title="0">{
        var reports []*output.DiagnosticReport

        // Get list of ingress resources
        ingresses, err := id.getIngressResources(ctx, config.Namespace, config.AllNamespaces)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get ingress resources: %w", err)
        }</span>

        <span class="cov0" title="0">if len(ingresses) == 0 </span><span class="cov0" title="0">{
                id.output.PrintInfo("No ingress resources found in the specified namespace(s)")
                return reports, nil
        }</span>

        <span class="cov0" title="0">id.output.PrintInfo(fmt.Sprintf("üîç Analyzing %d ingress resources", len(ingresses)))

        // Diagnose each ingress
        for _, ingress := range ingresses </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return reports, ctx.Err()
                }</span>

                <span class="cov0" title="0">ingressConfig := config
                ingressConfig.Namespace = ingress.Namespace

                report, err := id.DiagnoseIngress(ctx, ingress.Name, ingressConfig)
                if err != nil </span><span class="cov0" title="0">{
                        id.output.PrintError("Failed to diagnose ingress", fmt.Errorf("ingress %s: %w", ingress.Name, err))
                        continue</span>
                }

                <span class="cov0" title="0">reports = append(reports, report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

// analyzeIngress performs comprehensive analysis of a single ingress resource
func (id *IngressDiagnostic) analyzeIngress(ctx context.Context, namespace, name string) (*IngressInfo, error) <span class="cov0" title="0">{
        // Get the ingress resource
        ingress, err := id.client.Clientset.NetworkingV1().Ingresses(namespace).Get(ctx, name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get ingress: %w", err)
        }</span>

        <span class="cov0" title="0">info := &amp;IngressInfo{
                Ingress: ingress,
        }

        // Get backend services
        info.BackendServices, err = id.getBackendServices(ctx, ingress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get backend services: %w", err)
        }</span>

        // Get backend endpoints
        <span class="cov0" title="0">info.BackendEndpoints, err = id.getBackendEndpoints(ctx, ingress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get backend endpoints: %w", err)
        }</span>

        // Get TLS secrets
        <span class="cov0" title="0">if len(ingress.Spec.TLS) &gt; 0 </span><span class="cov0" title="0">{
                info.TLSSecrets, err = id.getTLSSecrets(ctx, ingress)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get TLS secrets: %w", err)
                }</span>
        }

        // Get load balancer IP if available
        <span class="cov0" title="0">info.LoadBalancerIP = id.getLoadBalancerIP(ingress)

        return info, nil</span>
}

// runIngressChecks runs all diagnostic checks for an ingress resource
func (id *IngressDiagnostic) runIngressChecks(ctx context.Context, info *IngressInfo, config DiagnosticConfig) []output.CheckResult <span class="cov0" title="0">{
        var results []output.CheckResult

        // Define available checks
        allChecks := map[string]func(context.Context, *IngressInfo, DiagnosticConfig) output.CheckResult{
                "existence": id.checkIngressExists,
                "config":    id.checkIngressConfiguration,
                "backends":  id.checkBackendServices,
                "endpoints": id.checkBackendEndpoints,
                "ssl":       id.checkSSLConfiguration,
        }

        // Determine which checks to run
        checksToRun := config.Checks
        if len(checksToRun) == 0 </span><span class="cov0" title="0">{
                // Default checks
                checksToRun = []string{"existence", "config", "backends", "endpoints"}

                // Add SSL checks if TLS is configured
                if len(info.Ingress.Spec.TLS) &gt; 0 </span><span class="cov0" title="0">{
                        checksToRun = append(checksToRun, "ssl")
                }</span>
        }

        // Run selected checks
        <span class="cov0" title="0">for _, checkName := range checksToRun </span><span class="cov0" title="0">{
                if checkFunc, exists := allChecks[checkName]; exists </span><span class="cov0" title="0">{
                        result := checkFunc(ctx, info, config)
                        results = append(results, result)
                }</span>
        }

        <span class="cov0" title="0">return results</span>
}

// checkIngressExists verifies that the ingress resource exists and is accessible
func (id *IngressDiagnostic) checkIngressExists(ctx context.Context, info *IngressInfo, config DiagnosticConfig) output.CheckResult <span class="cov8" title="1">{
        if info.Ingress == nil </span><span class="cov8" title="1">{
                return output.CheckResult{
                        Name:       "Ingress Existence",
                        Status:     output.StatusFailed,
                        Message:    "Ingress resource not found",
                        Suggestion: fmt.Sprintf("Create ingress or check ingress name in namespace %s", config.Namespace),
                        Details: map[string]string{
                                "namespace": config.Namespace,
                        },
                }
        }</span>

        <span class="cov8" title="1">return output.CheckResult{
                Name:    "Ingress Existence",
                Status:  output.StatusPassed,
                Message: "Ingress resource exists and is accessible",
                Details: map[string]string{
                        "name":      info.Ingress.Name,
                        "namespace": info.Ingress.Namespace,
                        "class":     getIngressClass(info.Ingress),
                        "created":   info.Ingress.CreationTimestamp.Time.Format(time.RFC3339),
                        "age":       time.Since(info.Ingress.CreationTimestamp.Time).Round(time.Second).String(),
                },
        }</span>
}

// checkIngressConfiguration validates the ingress resource configuration
func (id *IngressDiagnostic) checkIngressConfiguration(ctx context.Context, info *IngressInfo, config DiagnosticConfig) output.CheckResult <span class="cov8" title="1">{
        var issues []string
        var warnings []string

        ingress := info.Ingress

        // Check if ingress has rules
        if len(ingress.Spec.Rules) == 0 </span><span class="cov8" title="1">{
                issues = append(issues, "No ingress rules defined")
        }</span>

        // Check for empty hosts in rules
        <span class="cov8" title="1">hasEmptyHost := false
        for _, rule := range ingress.Spec.Rules </span><span class="cov8" title="1">{
                if rule.Host == "" </span><span class="cov0" title="0">{
                        hasEmptyHost = true
                }</span>
        }
        <span class="cov8" title="1">if hasEmptyHost </span><span class="cov0" title="0">{
                warnings = append(warnings, "Some rules have empty host (catch-all)")
        }</span>

        // Check for missing default backend
        <span class="cov8" title="1">if ingress.Spec.DefaultBackend == nil &amp;&amp; hasEmptyHost </span><span class="cov0" title="0">{
                warnings = append(warnings, "No default backend defined for catch-all rules")
        }</span>

        // Check for deprecated API version
        <span class="cov8" title="1">if ingress.APIVersion == "extensions/v1beta1" || ingress.APIVersion == "networking.k8s.io/v1beta1" </span><span class="cov0" title="0">{
                warnings = append(warnings, "Using deprecated ingress API version, consider upgrading to networking.k8s.io/v1")
        }</span>

        <span class="cov8" title="1">if len(issues) &gt; 0 </span><span class="cov8" title="1">{
                return output.CheckResult{
                        Name:       "Ingress Configuration",
                        Status:     output.StatusFailed,
                        Message:    fmt.Sprintf("Configuration issues found: %s", strings.Join(issues, ", ")),
                        Suggestion: "Review and fix the configuration issues",
                        Details: map[string]string{
                                "issues":     strings.Join(issues, ", "),
                                "warnings":   strings.Join(warnings, ", "),
                                "rulesCount": fmt.Sprintf("%d", len(ingress.Spec.Rules)),
                                "apiVersion": ingress.APIVersion,
                        },
                }
        }</span>

        <span class="cov8" title="1">if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Ingress Configuration",
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("Configuration warnings: %s", strings.Join(warnings, ", ")),
                        Suggestion: "Consider addressing these warnings",
                        Details: map[string]string{
                                "warnings":   strings.Join(warnings, ", "),
                                "rulesCount": fmt.Sprintf("%d", len(ingress.Spec.Rules)),
                                "apiVersion": ingress.APIVersion,
                        },
                }
        }</span>

        <span class="cov8" title="1">return output.CheckResult{
                Name:    "Ingress Configuration",
                Status:  output.StatusPassed,
                Message: "Ingress configuration is valid",
                Details: map[string]string{
                        "rulesCount": fmt.Sprintf("%d", len(ingress.Spec.Rules)),
                        "apiVersion": ingress.APIVersion,
                        "class":      getIngressClass(ingress),
                },
        }</span>
}

// checkBackendServices validates that backend services exist and are properly configured
func (id *IngressDiagnostic) checkBackendServices(ctx context.Context, info *IngressInfo, config DiagnosticConfig) output.CheckResult <span class="cov0" title="0">{
        var issues []string
        var serviceCount int

        for _, rule := range info.Ingress.Spec.Rules </span><span class="cov0" title="0">{
                if rule.HTTP == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, path := range rule.HTTP.Paths </span><span class="cov0" title="0">{
                        if path.Backend.Service == nil </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("Path %s has no service backend", path.Path))
                                continue</span>
                        }

                        <span class="cov0" title="0">serviceName := path.Backend.Service.Name
                        servicePort := path.Backend.Service.Port

                        // Check if service exists in backend services
                        found := false
                        for _, svc := range info.BackendServices </span><span class="cov0" title="0">{
                                if svc.Name == serviceName </span><span class="cov0" title="0">{
                                        found = true
                                        serviceCount++

                                        // Validate port
                                        portFound := false
                                        for _, port := range svc.Spec.Ports </span><span class="cov0" title="0">{
                                                if (servicePort.Number != 0 &amp;&amp; port.Port == servicePort.Number) ||
                                                        (servicePort.Name != "" &amp;&amp; port.Name == servicePort.Name) </span><span class="cov0" title="0">{
                                                        portFound = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !portFound </span><span class="cov0" title="0">{
                                                issues = append(issues, fmt.Sprintf("Service %s does not expose port %v", serviceName, servicePort))
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("Backend service %s not found", serviceName))
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Backend Services",
                        Status:     output.StatusFailed,
                        Message:    fmt.Sprintf("Backend service issues found: %d problems", len(issues)),
                        Suggestion: "Fix backend service configurations and ensure services exist",
                        Details: map[string]string{
                                "issues":       strings.Join(issues, ", "),
                                "serviceCount": fmt.Sprintf("%d", serviceCount),
                                "problems":     fmt.Sprintf("%d", len(issues)),
                        },
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "Backend Services",
                Status:  output.StatusPassed,
                Message: fmt.Sprintf("All %d backend services are properly configured", serviceCount),
                Details: map[string]string{
                        "serviceCount": fmt.Sprintf("%d", serviceCount),
                        "status":       "all services validated",
                },
        }</span>
}

// checkBackendEndpoints validates that backend services have healthy endpoints
func (id *IngressDiagnostic) checkBackendEndpoints(ctx context.Context, info *IngressInfo, config DiagnosticConfig) output.CheckResult <span class="cov0" title="0">{
        var issues []string
        var totalEndpoints, readyEndpoints int

        for _, rule := range info.Ingress.Spec.Rules </span><span class="cov0" title="0">{
                if rule.HTTP == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, path := range rule.HTTP.Paths </span><span class="cov0" title="0">{
                        if path.Backend.Service == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">serviceName := path.Backend.Service.Name

                        // Find corresponding endpoint slices
                        for _, endpointSlice := range info.BackendEndpoints </span><span class="cov0" title="0">{
                                // Check if this endpoint slice belongs to the service
                                if serviceName, exists := endpointSlice.Labels["kubernetes.io/service-name"]; !exists || serviceName != path.Backend.Service.Name </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">if len(endpointSlice.Endpoints) == 0 </span><span class="cov0" title="0">{
                                        issues = append(issues, fmt.Sprintf("Service %s has no endpoints", serviceName))
                                        continue</span>
                                }

                                <span class="cov0" title="0">for _, endpoint := range endpointSlice.Endpoints </span><span class="cov0" title="0">{
                                        totalEndpoints++
                                        if endpoint.Conditions.Ready != nil &amp;&amp; *endpoint.Conditions.Ready </span><span class="cov0" title="0">{
                                                readyEndpoints++
                                        }</span> else<span class="cov0" title="0"> {
                                                issues = append(issues, fmt.Sprintf("Service %s has unready endpoints", serviceName))
                                        }</span>
                                }
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        <span class="cov0" title="0">if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Backend Endpoints",
                        Status:     output.StatusFailed,
                        Message:    fmt.Sprintf("Endpoint issues found: %d problems", len(issues)),
                        Suggestion: "Check pod health and service selectors",
                        Details: map[string]string{
                                "issues":         strings.Join(issues, ", "),
                                "totalEndpoints": fmt.Sprintf("%d", totalEndpoints),
                                "readyEndpoints": fmt.Sprintf("%d", readyEndpoints),
                                "problems":       fmt.Sprintf("%d", len(issues)),
                        },
                }
        }</span>

        <span class="cov0" title="0">if readyEndpoints == 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Backend Endpoints",
                        Status:     output.StatusFailed,
                        Message:    "No ready endpoints found for any backend services",
                        Suggestion: "Check pod status and ensure pods are running and ready",
                        Details: map[string]string{
                                "readyEndpoints": fmt.Sprintf("%d", readyEndpoints),
                                "totalEndpoints": fmt.Sprintf("%d", totalEndpoints),
                                "status":         "no ready endpoints",
                        },
                }
        }</span>

        <span class="cov0" title="0">if readyEndpoints &lt; totalEndpoints </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Backend Endpoints",
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("Some endpoints not ready: %d/%d ready", readyEndpoints, totalEndpoints),
                        Suggestion: "Check why some endpoints are not ready",
                        Details: map[string]string{
                                "readyEndpoints": fmt.Sprintf("%d", readyEndpoints),
                                "totalEndpoints": fmt.Sprintf("%d", totalEndpoints),
                                "readyRatio":     fmt.Sprintf("%.1f%%", float64(readyEndpoints)/float64(totalEndpoints)*100),
                        },
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "Backend Endpoints",
                Status:  output.StatusPassed,
                Message: fmt.Sprintf("All %d endpoints are ready", readyEndpoints),
                Details: map[string]string{
                        "readyEndpoints": fmt.Sprintf("%d", readyEndpoints),
                        "totalEndpoints": fmt.Sprintf("%d", totalEndpoints),
                        "status":         "all endpoints healthy",
                },
        }</span>
}

// checkSSLConfiguration validates SSL/TLS configuration
func (id *IngressDiagnostic) checkSSLConfiguration(ctx context.Context, info *IngressInfo, config DiagnosticConfig) output.CheckResult <span class="cov0" title="0">{
        if len(info.Ingress.Spec.TLS) == 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:    "SSL Configuration",
                        Status:  output.StatusSkipped,
                        Message: "No TLS configuration found",
                        Details: map[string]string{
                                "tlsCount": "0",
                                "status":   "no TLS configuration",
                        },
                }
        }</span>

        <span class="cov0" title="0">var issues []string
        var warnings []string

        for _, tls := range info.Ingress.Spec.TLS </span><span class="cov0" title="0">{
                if tls.SecretName == "" </span><span class="cov0" title="0">{
                        issues = append(issues, "TLS block has no secret name specified")
                        continue</span>
                }

                // Check if secret exists
                <span class="cov0" title="0">secretFound := false
                for _, secret := range info.TLSSecrets </span><span class="cov0" title="0">{
                        if secret.Name == tls.SecretName </span><span class="cov0" title="0">{
                                secretFound = true

                                // Validate secret type
                                if secret.Type != corev1.SecretTypeTLS </span><span class="cov0" title="0">{
                                        warnings = append(warnings, fmt.Sprintf("Secret %s is not of type kubernetes.io/tls", tls.SecretName))
                                }</span>

                                // Check for required keys
                                <span class="cov0" title="0">if _, hasCert := secret.Data["tls.crt"]; !hasCert </span><span class="cov0" title="0">{
                                        issues = append(issues, fmt.Sprintf("Secret %s missing tls.crt", tls.SecretName))
                                }</span>
                                <span class="cov0" title="0">if _, hasKey := secret.Data["tls.key"]; !hasKey </span><span class="cov0" title="0">{
                                        issues = append(issues, fmt.Sprintf("Secret %s missing tls.key", tls.SecretName))
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }

                <span class="cov0" title="0">if !secretFound </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("TLS secret %s not found", tls.SecretName))
                }</span>

                // Validate hosts
                <span class="cov0" title="0">if len(tls.Hosts) == 0 </span><span class="cov0" title="0">{
                        warnings = append(warnings, fmt.Sprintf("TLS block for secret %s has no hosts specified", tls.SecretName))
                }</span>
        }

        <span class="cov0" title="0">if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "SSL Configuration",
                        Status:     output.StatusFailed,
                        Message:    fmt.Sprintf("SSL configuration issues: %s", strings.Join(issues, ", ")),
                        Suggestion: "Fix SSL/TLS configuration issues",
                        Details: map[string]string{
                                "issues":   strings.Join(issues, ", "),
                                "warnings": strings.Join(warnings, ", "),
                                "tlsCount": fmt.Sprintf("%d", len(info.Ingress.Spec.TLS)),
                        },
                }
        }</span>

        <span class="cov0" title="0">if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "SSL Configuration",
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("SSL configuration warnings: %s", strings.Join(warnings, ", ")),
                        Suggestion: "Consider addressing SSL/TLS warnings",
                        Details: map[string]string{
                                "warnings": strings.Join(warnings, ", "),
                                "tlsCount": fmt.Sprintf("%d", len(info.Ingress.Spec.TLS)),
                        },
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "SSL Configuration",
                Status:  output.StatusPassed,
                Message: fmt.Sprintf("SSL configuration is valid for %d TLS blocks", len(info.Ingress.Spec.TLS)),
                Details: map[string]string{
                        "tlsCount": fmt.Sprintf("%d", len(info.Ingress.Spec.TLS)),
                        "status":   "all TLS configurations valid",
                },
        }</span>
}

// Helper methods

// getIngressResources retrieves ingress resources from specified namespace(s)
func (id *IngressDiagnostic) getIngressResources(ctx context.Context, namespace string, allNamespaces bool) ([]*networkingv1.Ingress, error) <span class="cov0" title="0">{
        var ingresses []*networkingv1.Ingress

        if allNamespaces </span><span class="cov0" title="0">{
                ingressList, err := id.client.Clientset.NetworkingV1().Ingresses("").List(ctx, metav1.ListOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">for i := range ingressList.Items </span><span class="cov0" title="0">{
                        ingresses = append(ingresses, &amp;ingressList.Items[i])
                }</span>
        } else<span class="cov0" title="0"> {
                ingressList, err := id.client.Clientset.NetworkingV1().Ingresses(namespace).List(ctx, metav1.ListOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">for i := range ingressList.Items </span><span class="cov0" title="0">{
                        ingresses = append(ingresses, &amp;ingressList.Items[i])
                }</span>
        }

        <span class="cov0" title="0">return ingresses, nil</span>
}

// getBackendServices retrieves all backend services referenced by the ingress
func (id *IngressDiagnostic) getBackendServices(ctx context.Context, ingress *networkingv1.Ingress) ([]*corev1.Service, error) <span class="cov0" title="0">{
        var services []*corev1.Service
        serviceNames := make(map[string]bool)

        // Extract service names from ingress rules
        for _, rule := range ingress.Spec.Rules </span><span class="cov0" title="0">{
                if rule.HTTP == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, path := range rule.HTTP.Paths </span><span class="cov0" title="0">{
                        if path.Backend.Service != nil </span><span class="cov0" title="0">{
                                serviceNames[path.Backend.Service.Name] = true
                        }</span>
                }
        }

        // Get each service
        <span class="cov0" title="0">for serviceName := range serviceNames </span><span class="cov0" title="0">{
                service, err := id.client.Clientset.CoreV1().Services(ingress.Namespace).Get(ctx, serviceName, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        // Service not found - we'll report this in the check
                        continue</span>
                }
                <span class="cov0" title="0">services = append(services, service)</span>
        }

        <span class="cov0" title="0">return services, nil</span>
}

// getBackendEndpoints retrieves endpoint slices for backend services
func (id *IngressDiagnostic) getBackendEndpoints(ctx context.Context, ingress *networkingv1.Ingress) ([]*discoveryv1.EndpointSlice, error) <span class="cov0" title="0">{
        var endpoints []*discoveryv1.EndpointSlice
        serviceNames := make(map[string]bool)

        // Extract service names from ingress rules
        for _, rule := range ingress.Spec.Rules </span><span class="cov0" title="0">{
                if rule.HTTP == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, path := range rule.HTTP.Paths </span><span class="cov0" title="0">{
                        if path.Backend.Service != nil </span><span class="cov0" title="0">{
                                serviceNames[path.Backend.Service.Name] = true
                        }</span>
                }
        }

        // Get endpoint slices for each service
        <span class="cov0" title="0">for serviceName := range serviceNames </span><span class="cov0" title="0">{
                // List endpoint slices that match the service
                endpointSlices, err := id.client.Clientset.DiscoveryV1().EndpointSlices(ingress.Namespace).List(ctx, metav1.ListOptions{
                        LabelSelector: fmt.Sprintf("kubernetes.io/service-name=%s", serviceName),
                })
                if err != nil </span><span class="cov0" title="0">{
                        // EndpointSlices not found - we'll report this in the check
                        continue</span>
                }
                <span class="cov0" title="0">for i := range endpointSlices.Items </span><span class="cov0" title="0">{
                        endpoints = append(endpoints, &amp;endpointSlices.Items[i])
                }</span>
        }

        <span class="cov0" title="0">return endpoints, nil</span>
}

// getTLSSecrets retrieves TLS secrets referenced by the ingress
func (id *IngressDiagnostic) getTLSSecrets(ctx context.Context, ingress *networkingv1.Ingress) ([]*corev1.Secret, error) <span class="cov0" title="0">{
        var secrets []*corev1.Secret
        secretNames := make(map[string]bool)

        // Extract secret names from TLS configuration
        for _, tls := range ingress.Spec.TLS </span><span class="cov0" title="0">{
                if tls.SecretName != "" </span><span class="cov0" title="0">{
                        secretNames[tls.SecretName] = true
                }</span>
        }

        // Get each secret
        <span class="cov0" title="0">for secretName := range secretNames </span><span class="cov0" title="0">{
                secret, err := id.client.Clientset.CoreV1().Secrets(ingress.Namespace).Get(ctx, secretName, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        // Secret not found - we'll report this in the check
                        continue</span>
                }
                <span class="cov0" title="0">secrets = append(secrets, secret)</span>
        }

        <span class="cov0" title="0">return secrets, nil</span>
}

// getLoadBalancerIP extracts the load balancer IP from ingress status
func (id *IngressDiagnostic) getLoadBalancerIP(ingress *networkingv1.Ingress) string <span class="cov0" title="0">{
        if len(ingress.Status.LoadBalancer.Ingress) &gt; 0 </span><span class="cov0" title="0">{
                if ingress.Status.LoadBalancer.Ingress[0].IP != "" </span><span class="cov0" title="0">{
                        return ingress.Status.LoadBalancer.Ingress[0].IP
                }</span>
                <span class="cov0" title="0">if ingress.Status.LoadBalancer.Ingress[0].Hostname != "" </span><span class="cov0" title="0">{
                        return ingress.Status.LoadBalancer.Ingress[0].Hostname
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// getIngressClass returns the ingress class name or "default" if not specified
func getIngressClass(ingress *networkingv1.Ingress) string <span class="cov8" title="1">{
        if ingress.Spec.IngressClassName != nil </span><span class="cov8" title="1">{
                return *ingress.Spec.IngressClassName
        }</span>
        <span class="cov8" title="1">if class, exists := ingress.Annotations["kubernetes.io/ingress.class"]; exists </span><span class="cov8" title="1">{
                return class
        }</span>
        <span class="cov8" title="1">return "default"</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package pod

import (
        "context"
        "fmt"
        "regexp"
        "strings"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"

        "kdebug/internal/output"
)

// runDiagnosticChecks executes all diagnostic checks for a pod.
func (d *PodDiagnostic) runDiagnosticChecks(ctx context.Context, info *PodInfo, config DiagnosticConfig) []output.CheckResult <span class="cov0" title="0">{
        // Determine which checks to run
        checkTypes := config.Checks
        if len(checkTypes) == 0 </span><span class="cov0" title="0">{
                // Run all checks if none specified
                checkTypes = []string{"basic", "scheduling", "images", "rbac", "logs", "init-containers", "resources", "network"}
        }</span>

        // Pre-allocate slice with estimated capacity
        <span class="cov0" title="0">checks := make([]output.CheckResult, 0, len(checkTypes)*3)

        for _, checkType := range checkTypes </span><span class="cov0" title="0">{
                switch checkType </span>{
                case "basic":<span class="cov0" title="0">
                        checks = append(checks, d.checkPodBasicStatus(info))</span>
                case "scheduling":<span class="cov0" title="0">
                        checks = append(checks, d.checkPodScheduling(ctx, info)...)</span>
                case "images":<span class="cov0" title="0">
                        checks = append(checks, d.checkImageIssues(info)...)</span>
                case "rbac":<span class="cov0" title="0">
                        checks = append(checks, d.checkRBACPermissions(ctx, info)...)</span>
                case "logs":<span class="cov0" title="0">
                        if config.IncludeLogs </span><span class="cov0" title="0">{
                                checks = append(checks, d.checkContainerLogs(info)...)
                        }</span>
                case "init-containers":<span class="cov0" title="0">
                        checks = append(checks, d.checkInitContainers(info)...)</span>
                case "resources":<span class="cov0" title="0">
                        checks = append(checks, d.checkResourceConstraints(info)...)</span>
                case "network":<span class="cov0" title="0">
                        checks = append(checks, d.checkNetworkIssues(info)...)</span>
                }
        }

        <span class="cov0" title="0">return checks</span>
}

// checkPodBasicStatus performs basic pod status checks.
func (d *PodDiagnostic) checkPodBasicStatus(info *PodInfo) output.CheckResult <span class="cov8" title="1">{
        pod := info.Pod

        switch pod.Status.Phase </span>{
        case corev1.PodRunning:<span class="cov8" title="1">
                // Check if all containers are ready
                readyContainers := 0
                totalContainers := len(pod.Status.ContainerStatuses)

                for _, status := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                        if status.Ready </span><span class="cov8" title="1">{
                                readyContainers++
                        }</span>
                }

                <span class="cov8" title="1">if readyContainers == totalContainers </span><span class="cov8" title="1">{
                        return output.CheckResult{
                                Name:    "Pod Status",
                                Status:  output.StatusPassed,
                                Message: fmt.Sprintf("Pod is running with %d/%d containers ready", readyContainers, totalContainers),
                                Details: map[string]string{
                                        "phase": string(pod.Status.Phase),
                                        "ready": formatConditionStatus(getPodCondition(pod, corev1.PodReady)),
                                },
                        }
                }</span>

                <span class="cov8" title="1">return output.CheckResult{
                        Name:       "Pod Status",
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("Pod is running but only %d/%d containers are ready", readyContainers, totalContainers),
                        Suggestion: "Check individual container statuses and logs",
                        Details: map[string]string{
                                "phase": string(pod.Status.Phase),
                        },
                }</span>

        case corev1.PodPending:<span class="cov8" title="1">
                return output.CheckResult{
                        Name:       "Pod Status",
                        Status:     output.StatusFailed,
                        Message:    "Pod is stuck in Pending state",
                        Suggestion: "Check scheduling constraints, resource availability, and node conditions",
                        Details: map[string]string{
                                "phase": string(pod.Status.Phase),
                                "age":   time.Since(pod.CreationTimestamp.Time).Truncate(time.Second).String(),
                        },
                }</span>

        case corev1.PodFailed:<span class="cov8" title="1">
                return output.CheckResult{
                        Name:       "Pod Status",
                        Status:     output.StatusFailed,
                        Message:    "Pod has failed",
                        Suggestion: "Check container exit codes and logs for failure reasons",
                        Details: map[string]string{
                                "phase":  string(pod.Status.Phase),
                                "reason": pod.Status.Reason,
                        },
                }</span>

        case corev1.PodSucceeded:<span class="cov8" title="1">
                return output.CheckResult{
                        Name:    "Pod Status",
                        Status:  output.StatusPassed,
                        Message: "Pod completed successfully",
                        Details: map[string]string{
                                "phase": string(pod.Status.Phase),
                        },
                }</span>

        default:<span class="cov0" title="0">
                return output.CheckResult{
                        Name:       "Pod Status",
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("Pod is in unknown phase: %s", pod.Status.Phase),
                        Suggestion: "Investigate pod events and cluster status",
                        Details: map[string]string{
                                "phase": string(pod.Status.Phase),
                        },
                }</span>
        }
}

// checkPodScheduling checks for pod scheduling issues.
func (d *PodDiagnostic) checkPodScheduling(_ context.Context, info *PodInfo) []output.CheckResult <span class="cov0" title="0">{
        checks := make([]output.CheckResult, 0, 3) // Pre-allocate for expected number of checks
        pod := info.Pod

        // Check if pod is scheduled
        if pod.Spec.NodeName == "" </span><span class="cov0" title="0">{
                checks = append(checks, output.CheckResult{
                        Name:       "Pod Scheduling",
                        Status:     output.StatusFailed,
                        Message:    "Pod is not scheduled to any node",
                        Suggestion: d.getSchedulingSuggestion(info),
                        Details: map[string]string{
                                "scheduled": "false",
                                "message":   "Pod remains unscheduled - check resource requirements and node availability",
                        },
                })
        }</span> else<span class="cov0" title="0"> {
                checks = append(checks, output.CheckResult{
                        Name:    "Pod Scheduling",
                        Status:  output.StatusPassed,
                        Message: fmt.Sprintf("Pod is scheduled on node '%s'", pod.Spec.NodeName),
                        Details: map[string]string{
                                "node":      pod.Spec.NodeName,
                                "scheduled": "true",
                        },
                })

                // If we have node info, check node conditions
                if info.Node != nil </span><span class="cov0" title="0">{
                        checks = append(checks, d.checkNodeConditions(info.Node))
                }</span>
        }

        // Check resource requests vs node capacity
        <span class="cov0" title="0">if pod.Spec.NodeName != "" &amp;&amp; info.Node != nil </span><span class="cov0" title="0">{
                checks = append(checks, d.checkResourceFit(pod, info.Node))
        }</span>

        <span class="cov0" title="0">return checks</span>
}

// checkImageIssues checks for image pull problems.
func (d *PodDiagnostic) checkImageIssues(info *PodInfo) []output.CheckResult <span class="cov8" title="1">{
        checks := make([]output.CheckResult, 0, len(info.Pod.Status.ContainerStatuses)+len(info.Pod.Status.InitContainerStatuses)) // Pre-allocate based on containers
        pod := info.Pod

        // Check container image statuses
        for _, status := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if status.State.Waiting != nil </span><span class="cov8" title="1">{
                        reason := status.State.Waiting.Reason
                        message := status.State.Waiting.Message

                        switch reason </span>{
                        case "ErrImagePull", "ImagePullBackOff":<span class="cov8" title="1">
                                checks = append(checks, output.CheckResult{
                                        Name:       fmt.Sprintf("Container %s - Image Pull", status.Name),
                                        Status:     output.StatusFailed,
                                        Message:    fmt.Sprintf("Failed to pull image: %s", message),
                                        Suggestion: d.getImagePullSuggestion(status.Image, message),
                                        Details: map[string]string{
                                                "image":  status.Image,
                                                "reason": reason,
                                        },
                                })</span>

                        case "InvalidImageName":<span class="cov8" title="1">
                                checks = append(checks, output.CheckResult{
                                        Name:       fmt.Sprintf("Container %s - Image Name", status.Name),
                                        Status:     output.StatusFailed,
                                        Message:    fmt.Sprintf("Invalid image name: %s", status.Image),
                                        Suggestion: "Verify the image name format and registry URL",
                                        Details: map[string]string{
                                                "image": status.Image,
                                        },
                                })</span>

                        default:<span class="cov0" title="0">
                                if strings.Contains(strings.ToLower(reason), "image") </span><span class="cov0" title="0">{
                                        checks = append(checks, output.CheckResult{
                                                Name:       fmt.Sprintf("Container %s - Image Issue", status.Name),
                                                Status:     output.StatusWarning,
                                                Message:    fmt.Sprintf("Image-related issue: %s", reason),
                                                Suggestion: "Check image availability and registry connectivity",
                                                Details: map[string]string{
                                                        "image":  status.Image,
                                                        "reason": reason,
                                                },
                                        })
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        switch </span>{
                        case status.State.Running != nil, status.State.Terminated != nil:<span class="cov8" title="1">
                                // Image pulled successfully
                                checks = append(checks, output.CheckResult{
                                        Name:    fmt.Sprintf("Container %s - Image Pull", status.Name),
                                        Status:  output.StatusPassed,
                                        Message: "Image pulled successfully",
                                        Details: map[string]string{
                                                "image": status.Image,
                                        },
                                })</span>
                        }
                }
        }

        // If no container statuses yet, check init containers
        <span class="cov8" title="1">if len(pod.Status.ContainerStatuses) == 0 </span><span class="cov8" title="1">{
                for _, status := range pod.Status.InitContainerStatuses </span><span class="cov8" title="1">{
                        if status.State.Waiting != nil &amp;&amp; strings.Contains(status.State.Waiting.Reason, "Image") </span><span class="cov8" title="1">{
                                checks = append(checks, output.CheckResult{
                                        Name:       fmt.Sprintf("Init Container %s - Image Pull", status.Name),
                                        Status:     output.StatusFailed,
                                        Message:    fmt.Sprintf("Failed to pull image: %s", status.State.Waiting.Message),
                                        Suggestion: d.getImagePullSuggestion(status.Image, status.State.Waiting.Message),
                                        Details: map[string]string{
                                                "image":  status.Image,
                                                "reason": status.State.Waiting.Reason,
                                        },
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">return checks</span>
}

// checkRBACPermissions validates RBAC permissions for the pod.
func (d *PodDiagnostic) checkRBACPermissions(_ context.Context, info *PodInfo) []output.CheckResult <span class="cov0" title="0">{
        checks := make([]output.CheckResult, 0, 2) // Pre-allocate for expected number of checks
        pod := info.Pod

        // Check if service account exists
        switch </span>{
        case pod.Spec.ServiceAccountName == "":<span class="cov0" title="0">
                checks = append(checks, output.CheckResult{
                        Name:    "RBAC - Service Account",
                        Status:  output.StatusPassed,
                        Message: "Using default service account",
                        Details: map[string]string{
                                "serviceAccount": "default",
                        },
                })</span>
        case info.ServiceAccount == nil:<span class="cov0" title="0">
                checks = append(checks, output.CheckResult{
                        Name:       "RBAC - Service Account",
                        Status:     output.StatusFailed,
                        Message:    fmt.Sprintf("Service account '%s' not found", pod.Spec.ServiceAccountName),
                        Suggestion: fmt.Sprintf("Create service account: kubectl create serviceaccount %s -n %s", pod.Spec.ServiceAccountName, pod.Namespace),
                        Details: map[string]string{
                                "serviceAccount": pod.Spec.ServiceAccountName,
                        },
                })</span>
        default:<span class="cov0" title="0">
                checks = append(checks, output.CheckResult{
                        Name:    "RBAC - Service Account",
                        Status:  output.StatusPassed,
                        Message: fmt.Sprintf("Service account '%s' exists", pod.Spec.ServiceAccountName),
                        Details: map[string]string{
                                "serviceAccount": pod.Spec.ServiceAccountName,
                        },
                })

                // Check for common RBAC issues in events
                checks = append(checks, d.checkRBACEvents(info)...)</span>
        }

        <span class="cov0" title="0">return checks</span>
}

// checkContainerLogs analyzes container logs for common issues.
func (d *PodDiagnostic) checkContainerLogs(info *PodInfo) []output.CheckResult <span class="cov0" title="0">{
        checks := make([]output.CheckResult, 0, len(info.Pod.Status.ContainerStatuses)) // Pre-allocate based on container count

        if len(info.ContainerLogs) == 0 </span><span class="cov0" title="0">{
                checks = append(checks, output.CheckResult{
                        Name:    "Container Logs",
                        Status:  output.StatusSkipped,
                        Message: "No container logs available",
                })
                return checks
        }</span>

        <span class="cov0" title="0">for containerName, logs := range info.ContainerLogs </span><span class="cov0" title="0">{
                if logs == "" </span><span class="cov0" title="0">{
                        checks = append(checks, output.CheckResult{
                                Name:    fmt.Sprintf("Container %s - Logs", containerName),
                                Status:  output.StatusWarning,
                                Message: "No log output available",
                                Details: map[string]string{
                                        "message": "Container may not have started or produced any logs",
                                },
                        })
                        continue</span>
                }

                // Analyze logs for common patterns
                <span class="cov0" title="0">logCheck := d.analyzeContainerLogs(containerName, logs)
                checks = append(checks, logCheck)

                // Check for crash loop indicators
                if d.isContainerCrashLooping(info.Pod, containerName) </span><span class="cov0" title="0">{
                        crashCheck := d.analyzeCrashLoopBackOff(containerName, logs, info.Pod)
                        checks = append(checks, crashCheck)
                }</span>
        }

        <span class="cov0" title="0">return checks</span>
}

// checkInitContainers checks init container status and issues.
func (d *PodDiagnostic) checkInitContainers(info *PodInfo) []output.CheckResult <span class="cov0" title="0">{
        checks := make([]output.CheckResult, 0, len(info.Pod.Spec.InitContainers)+1) // Pre-allocate based on init containers
        pod := info.Pod

        if len(pod.Spec.InitContainers) == 0 </span><span class="cov0" title="0">{
                checks = append(checks, output.CheckResult{
                        Name:    "Init Containers",
                        Status:  output.StatusSkipped,
                        Message: "No init containers defined",
                })
                return checks
        }</span>

        // Check each init container status
        <span class="cov0" title="0">for i, initContainer := range pod.Spec.InitContainers </span><span class="cov0" title="0">{
                if i &lt; len(pod.Status.InitContainerStatuses) </span><span class="cov0" title="0">{
                        status := pod.Status.InitContainerStatuses[i]
                        checks = append(checks, d.checkInitContainerStatus(initContainer.Name, status))
                }</span> else<span class="cov0" title="0"> {
                        checks = append(checks, output.CheckResult{
                                Name:    fmt.Sprintf("Init Container %s", initContainer.Name),
                                Status:  output.StatusWarning,
                                Message: "Init container status not available",
                        })
                }</span>
        }

        <span class="cov0" title="0">return checks</span>
}

// checkResourceConstraints analyzes resource requests, limits, and QoS.
func (d *PodDiagnostic) checkResourceConstraints(info *PodInfo) []output.CheckResult <span class="cov0" title="0">{
        checks := make([]output.CheckResult, 0, 3) // Pre-allocate for expected resource checks
        pod := info.Pod

        // Check QoS class
        checks = append(checks, d.checkQoSClass(pod))

        // Check resource requests and limits
        checks = append(checks, d.checkResourceRequests(pod))

        // Check for resource-related events
        checks = append(checks, d.checkResourceEvents(info))

        return checks
}</span>

// checkNetworkIssues analyzes network-related problems.
func (d *PodDiagnostic) checkNetworkIssues(info *PodInfo) []output.CheckResult <span class="cov0" title="0">{
        checks := make([]output.CheckResult, 0, 5) // Pre-allocate for expected network checks
        pod := info.Pod

        // Check if pod has IP address
        if pod.Status.PodIP == "" </span><span class="cov0" title="0">{
                checks = append(checks, output.CheckResult{
                        Name:       "Network - Pod IP",
                        Status:     output.StatusFailed,
                        Message:    "Pod has no IP address assigned",
                        Suggestion: "Check CNI plugin status and network configuration",
                })
        }</span> else<span class="cov0" title="0"> {
                checks = append(checks, output.CheckResult{
                        Name:    "Network - Pod IP",
                        Status:  output.StatusPassed,
                        Message: fmt.Sprintf("Pod IP assigned: %s", pod.Status.PodIP),
                        Details: map[string]string{
                                "podIP": pod.Status.PodIP,
                        },
                })
        }</span>

        // Check DNS configuration
        <span class="cov0" title="0">checks = append(checks, d.checkDNSConfiguration(pod))

        // Check for network-related events
        checks = append(checks, d.checkNetworkEvents(info))

        return checks</span>
}

// Helper functions for specific checks

func (d *PodDiagnostic) getSchedulingSuggestion(info *PodInfo) string <span class="cov0" title="0">{
        suggestions := []string{}

        // Check events for scheduling clues
        for _, event := range info.Events </span><span class="cov0" title="0">{
                if event.Reason == "FailedScheduling" </span><span class="cov0" title="0">{
                        if strings.Contains(event.Message, "Insufficient") </span><span class="cov0" title="0">{
                                suggestions = append(suggestions, "Insufficient resources - scale cluster or reduce resource requests")
                        }</span>
                        <span class="cov0" title="0">if strings.Contains(event.Message, "node(s) had taint") </span><span class="cov0" title="0">{
                                suggestions = append(suggestions, "Node taints prevent scheduling - add tolerations or remove taints")
                        }</span>
                        <span class="cov0" title="0">if strings.Contains(event.Message, "didn't match node selector") </span><span class="cov0" title="0">{
                                suggestions = append(suggestions, "Node selector mismatch - verify node labels")
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(suggestions) == 0 </span><span class="cov0" title="0">{
                suggestions = append(suggestions, "Check node availability, resource requirements, and scheduling constraints")
        }</span>

        <span class="cov0" title="0">return strings.Join(suggestions, "; ")</span>
}

func (d *PodDiagnostic) getImagePullSuggestion(image, message string) string <span class="cov8" title="1">{
        if strings.Contains(message, "not found") || strings.Contains(message, "manifest unknown") </span><span class="cov8" title="1">{
                return fmt.Sprintf("Image not found - verify image name and tag: %s", image)
        }</span>
        <span class="cov8" title="1">if strings.Contains(message, "unauthorized") || strings.Contains(message, "authentication") </span><span class="cov8" title="1">{
                return "Check registry credentials and image pull secrets"
        }</span>
        <span class="cov8" title="1">if strings.Contains(message, "timeout") || strings.Contains(message, "connection") </span><span class="cov8" title="1">{
                return "Check network connectivity to registry and DNS resolution"
        }</span>
        <span class="cov8" title="1">if strings.Contains(message, "pull rate limit") </span><span class="cov8" title="1">{
                return "Registry rate limit exceeded - configure pull secrets or use mirror registry"
        }</span>

        <span class="cov8" title="1">return "Check image name, registry accessibility, and authentication"</span>
}

func (d *PodDiagnostic) checkNodeConditions(node *corev1.Node) output.CheckResult <span class="cov0" title="0">{
        var issues []string

        for _, condition := range node.Status.Conditions </span><span class="cov0" title="0">{
                switch condition.Type </span>{
                case corev1.NodeReady:<span class="cov0" title="0">
                        if condition.Status != corev1.ConditionTrue </span><span class="cov0" title="0">{
                                issues = append(issues, "Node is not ready")
                        }</span>
                case corev1.NodeMemoryPressure:<span class="cov0" title="0">
                        if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                issues = append(issues, "Node under memory pressure")
                        }</span>
                case corev1.NodeDiskPressure:<span class="cov0" title="0">
                        if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                issues = append(issues, "Node under disk pressure")
                        }</span>
                case corev1.NodePIDPressure:<span class="cov0" title="0">
                        if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                issues = append(issues, "Node under PID pressure")
                        }</span>
                case corev1.NodeNetworkUnavailable:<span class="cov0" title="0">
                        if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                issues = append(issues, "Node network unavailable")
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       fmt.Sprintf("Node %s - Conditions", node.Name),
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("Node has issues: %s", strings.Join(issues, ", ")),
                        Suggestion: "Check node resources and system health",
                        Details: map[string]string{
                                "node": node.Name,
                        },
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    fmt.Sprintf("Node %s - Conditions", node.Name),
                Status:  output.StatusPassed,
                Message: "Node conditions are healthy",
                Details: map[string]string{
                        "node": node.Name,
                },
        }</span>
}

func (d *PodDiagnostic) checkResourceFit(pod *corev1.Pod, node *corev1.Node) output.CheckResult <span class="cov0" title="0">{
        // Calculate total resource requests
        totalCPU := resource.NewQuantity(0, resource.DecimalSI)
        totalMemory := resource.NewQuantity(0, resource.BinarySI)

        for _, container := range pod.Spec.Containers </span><span class="cov0" title="0">{
                if cpu := container.Resources.Requests[corev1.ResourceCPU]; !cpu.IsZero() </span><span class="cov0" title="0">{
                        totalCPU.Add(cpu)
                }</span>
                <span class="cov0" title="0">if memory := container.Resources.Requests[corev1.ResourceMemory]; !memory.IsZero() </span><span class="cov0" title="0">{
                        totalMemory.Add(memory)
                }</span>
        }

        // Get node allocatable resources
        <span class="cov0" title="0">nodeCPU := node.Status.Allocatable[corev1.ResourceCPU]
        nodeMemory := node.Status.Allocatable[corev1.ResourceMemory]

        var issues []string
        if totalCPU.Cmp(nodeCPU) &gt; 0 </span><span class="cov0" title="0">{
                issues = append(issues, fmt.Sprintf("CPU request (%s) exceeds node capacity (%s)", totalCPU.String(), nodeCPU.String()))
        }</span>
        <span class="cov0" title="0">if totalMemory.Cmp(nodeMemory) &gt; 0 </span><span class="cov0" title="0">{
                issues = append(issues, fmt.Sprintf("Memory request (%s) exceeds node capacity (%s)", totalMemory.String(), nodeMemory.String()))
        }</span>

        <span class="cov0" title="0">if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Resource Fit",
                        Status:     output.StatusWarning,
                        Message:    "Resource requests may exceed node capacity",
                        Suggestion: "Review resource requests or scale to larger nodes",
                        Details: map[string]string{
                                "issues": strings.Join(issues, "; "),
                        },
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "Resource Fit",
                Status:  output.StatusPassed,
                Message: "Resource requests fit within node capacity",
                Details: map[string]string{
                        "cpu":    fmt.Sprintf("%s/%s", totalCPU.String(), nodeCPU.String()),
                        "memory": fmt.Sprintf("%s/%s", totalMemory.String(), nodeMemory.String()),
                },
        }</span>
}

func (d *PodDiagnostic) checkRBACEvents(info *PodInfo) []output.CheckResult <span class="cov0" title="0">{
        checks := make([]output.CheckResult, 0, 5) // Pre-allocate for expected RBAC event checks

        for _, event := range info.Events </span><span class="cov0" title="0">{
                if strings.Contains(event.Message, "forbidden") ||
                        strings.Contains(event.Message, "unauthorized") ||
                        strings.Contains(event.Reason, "FailedMount") &amp;&amp; strings.Contains(event.Message, "secret") </span><span class="cov0" title="0">{

                        checks = append(checks, output.CheckResult{
                                Name:       "RBAC - Permission Check",
                                Status:     output.StatusFailed,
                                Message:    fmt.Sprintf("Permission denied: %s", event.Message),
                                Suggestion: "Check RBAC bindings and service account permissions",
                                Details: map[string]string{
                                        "event": event.Reason,
                                },
                        })
                }</span>
        }

        <span class="cov0" title="0">if len(checks) == 0 </span><span class="cov0" title="0">{
                checks = append(checks, output.CheckResult{
                        Name:    "RBAC - Permission Check",
                        Status:  output.StatusPassed,
                        Message: "No RBAC permission issues detected in events",
                })
        }</span>

        <span class="cov0" title="0">return checks</span>
}

func (d *PodDiagnostic) analyzeContainerLogs(containerName, logs string) output.CheckResult <span class="cov8" title="1">{
        lines := strings.Split(logs, "\n")

        errorPatterns := []struct {
                pattern    string
                message    string
                suggestion string
        }{
                {`(?i)(connection refused|connection denied)`, "Connection refused error detected", "Check service availability and network connectivity"},
                {`(?i)(no such host|host not found)`, "DNS resolution failure detected", "Check DNS configuration and hostname"},
                {`(?i)(permission denied|access denied)`, "Permission denied error detected", "Check file permissions and RBAC settings"},
                {`(?i)(out of memory|oom|memory limit)`, "Out of memory error detected", "Increase memory limits or optimize memory usage"},
                {`(?i)(disk.*full|no space left)`, "Disk space error detected", "Check available disk space and cleanup"},
                {`(?i)(authentication.*fail|login.*fail)`, "Authentication failure detected", "Check credentials and authentication configuration"},
                {`(?i)(timeout|timed out)`, "Timeout error detected", "Check network latency and increase timeout values"},
                {`(?i)(panic|fatal|error|exception)`, "Application error detected", "Check application logs and configuration"},
        }

        for _, pattern := range errorPatterns </span><span class="cov8" title="1">{
                re := regexp.MustCompile(pattern.pattern)
                for _, line := range lines </span><span class="cov8" title="1">{
                        if re.MatchString(line) </span><span class="cov8" title="1">{
                                return output.CheckResult{
                                        Name:       fmt.Sprintf("Container %s - Log Analysis", containerName),
                                        Status:     output.StatusFailed,
                                        Message:    pattern.message,
                                        Suggestion: pattern.suggestion,
                                        Details: map[string]string{
                                                "logLine": strings.TrimSpace(line),
                                        },
                                }
                        }</span>
                }
        }

        <span class="cov8" title="1">return output.CheckResult{
                Name:    fmt.Sprintf("Container %s - Log Analysis", containerName),
                Status:  output.StatusPassed,
                Message: "No critical errors detected in recent logs",
                Details: map[string]string{
                        "analyzed": fmt.Sprintf("%d log lines", len(lines)),
                },
        }</span>
}

func (d *PodDiagnostic) isContainerCrashLooping(pod *corev1.Pod, containerName string) bool <span class="cov8" title="1">{
        for _, status := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if status.Name == containerName </span><span class="cov8" title="1">{
                        return status.RestartCount &gt; 0 &amp;&amp;
                                status.State.Waiting != nil &amp;&amp;
                                status.State.Waiting.Reason == "CrashLoopBackOff"
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (d *PodDiagnostic) analyzeCrashLoopBackOff(containerName, logs string, pod *corev1.Pod) output.CheckResult <span class="cov0" title="0">{
        var restartCount int32
        for _, status := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                if status.Name == containerName </span><span class="cov0" title="0">{
                        restartCount = status.RestartCount
                        break</span>
                }
        }

        // Get last few lines for crash analysis
        <span class="cov0" title="0">lines := strings.Split(logs, "\n")
        lastLines := make([]string, 0)
        for i := len(lines) - 1; i &gt;= 0 &amp;&amp; len(lastLines) &lt; 3; i-- </span><span class="cov0" title="0">{
                if strings.TrimSpace(lines[i]) != "" </span><span class="cov0" title="0">{
                        lastLines = append([]string{strings.TrimSpace(lines[i])}, lastLines...)
                }</span>
        }

        <span class="cov0" title="0">suggestion := "Check container startup configuration and resource limits"
        if len(lastLines) &gt; 0 </span><span class="cov0" title="0">{
                lastLog := strings.Join(lastLines, "; ")
                if strings.Contains(strings.ToLower(lastLog), "exit") ||
                        strings.Contains(strings.ToLower(lastLog), "killed") </span><span class="cov0" title="0">{
                        suggestion = "Container is being killed - check exit codes and resource limits"
                }</span>
        }

        <span class="cov0" title="0">return output.CheckResult{
                Name:       fmt.Sprintf("Container %s - CrashLoopBackOff", containerName),
                Status:     output.StatusFailed,
                Message:    fmt.Sprintf("Container is crash looping (restart count: %d)", restartCount),
                Suggestion: suggestion,
                Details: map[string]string{
                        "recentLogs": strings.Join(lastLines, "; "),
                },
        }</span>
}

func (d *PodDiagnostic) checkInitContainerStatus(name string, status corev1.ContainerStatus) output.CheckResult <span class="cov0" title="0">{
        if status.State.Terminated != nil </span><span class="cov0" title="0">{
                if status.State.Terminated.ExitCode == 0 </span><span class="cov0" title="0">{
                        return output.CheckResult{
                                Name:    fmt.Sprintf("Init Container %s", name),
                                Status:  output.StatusPassed,
                                Message: "Init container completed successfully",
                                Details: map[string]string{
                                        "exitCode": fmt.Sprintf("%d", status.State.Terminated.ExitCode),
                                },
                        }
                }</span>

                <span class="cov0" title="0">return output.CheckResult{
                        Name:       fmt.Sprintf("Init Container %s", name),
                        Status:     output.StatusFailed,
                        Message:    fmt.Sprintf("Init container failed with exit code %d", status.State.Terminated.ExitCode),
                        Suggestion: "Check init container logs and configuration",
                        Details: map[string]string{
                                "reason":   status.State.Terminated.Reason,
                                "exitCode": fmt.Sprintf("%d", status.State.Terminated.ExitCode),
                        },
                }</span>
        }

        <span class="cov0" title="0">if status.State.Waiting != nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       fmt.Sprintf("Init Container %s", name),
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("Init container is waiting: %s", status.State.Waiting.Reason),
                        Suggestion: "Check init container image and dependencies",
                        Details: map[string]string{
                                "reason": status.State.Waiting.Reason,
                        },
                }
        }</span>

        <span class="cov0" title="0">if status.State.Running != nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:    fmt.Sprintf("Init Container %s", name),
                        Status:  output.StatusWarning,
                        Message: "Init container is still running",
                        Details: map[string]string{
                                "started": status.State.Running.StartedAt.Format(time.RFC3339),
                        },
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    fmt.Sprintf("Init Container %s", name),
                Status:  output.StatusWarning,
                Message: "Init container status unknown",
        }</span>
}

func (d *PodDiagnostic) checkQoSClass(pod *corev1.Pod) output.CheckResult <span class="cov8" title="1">{
        qosClass := pod.Status.QOSClass

        var message, suggestion string
        status := output.StatusPassed

        switch qosClass </span>{
        case corev1.PodQOSGuaranteed:<span class="cov8" title="1">
                message = "Pod has Guaranteed QoS class"
                suggestion = "Excellent - pod has dedicated resources"</span>
        case corev1.PodQOSBurstable:<span class="cov8" title="1">
                message = "Pod has Burstable QoS class"
                suggestion = "Good - pod can burst above requests but may be throttled"</span>
        case corev1.PodQOSBestEffort:<span class="cov8" title="1">
                message = "Pod has BestEffort QoS class"
                suggestion = "Warning - pod may be evicted first during resource pressure"
                status = output.StatusWarning</span>
        default:<span class="cov0" title="0">
                message = "Pod QoS class unknown"
                status = output.StatusWarning</span>
        }

        <span class="cov8" title="1">return output.CheckResult{
                Name:       "Resource QoS",
                Status:     status,
                Message:    message,
                Suggestion: suggestion,
                Details: map[string]string{
                        "qosClass": string(qosClass),
                },
        }</span>
}

func (d *PodDiagnostic) checkResourceRequests(pod *corev1.Pod) output.CheckResult <span class="cov8" title="1">{
        var hasRequests, hasLimits bool
        containers := make([]string, 0, len(pod.Spec.Containers)) // Pre-allocate based on container count

        for _, container := range pod.Spec.Containers </span><span class="cov8" title="1">{
                if len(container.Resources.Requests) &gt; 0 </span><span class="cov8" title="1">{
                        hasRequests = true
                }</span>
                <span class="cov8" title="1">if len(container.Resources.Limits) &gt; 0 </span><span class="cov8" title="1">{
                        hasLimits = true
                }</span>
                <span class="cov8" title="1">containers = append(containers, container.Name)</span>
        }

        <span class="cov8" title="1">var status output.CheckStatus
        var message, suggestion string

        switch </span>{
        case hasRequests &amp;&amp; hasLimits:<span class="cov8" title="1">
                status = output.StatusPassed
                message = "Resource requests and limits are configured"
                suggestion = "Good practice - helps with scheduling and prevents resource abuse"</span>
        case hasRequests:<span class="cov8" title="1">
                status = output.StatusWarning
                message = "Resource requests configured but no limits"
                suggestion = "Consider adding resource limits to prevent containers from consuming excessive resources"</span>
        case hasLimits:<span class="cov8" title="1">
                status = output.StatusWarning
                message = "Resource limits configured but no requests"
                suggestion = "Consider adding resource requests to help with pod scheduling"</span>
        default:<span class="cov8" title="1">
                status = output.StatusWarning
                message = "No resource requests or limits configured"
                suggestion = "Consider adding resource requests and limits for better scheduling and resource management"</span>
        }

        <span class="cov8" title="1">return output.CheckResult{
                Name:       "Resource Configuration",
                Status:     status,
                Message:    message,
                Suggestion: suggestion,
                Details: map[string]string{
                        "containers": strings.Join(containers, ", "),
                },
        }</span>
}

func (d *PodDiagnostic) checkResourceEvents(info *PodInfo) output.CheckResult <span class="cov0" title="0">{
        for _, event := range info.Events </span><span class="cov0" title="0">{
                if strings.Contains(event.Reason, "FailedScheduling") &amp;&amp;
                        strings.Contains(event.Message, "Insufficient") </span><span class="cov0" title="0">{
                        return output.CheckResult{
                                Name:       "Resource Events",
                                Status:     output.StatusFailed,
                                Message:    "Insufficient resources for scheduling",
                                Suggestion: "Scale cluster or reduce resource requests",
                                Details: map[string]string{
                                        "message": event.Message,
                                },
                        }
                }</span>

                <span class="cov0" title="0">if event.Reason == "OOMKilling" || strings.Contains(event.Message, "OOMKilled") </span><span class="cov0" title="0">{
                        return output.CheckResult{
                                Name:       "Resource Events",
                                Status:     output.StatusFailed,
                                Message:    "Container was killed due to out of memory",
                                Suggestion: "Increase memory limits or optimize memory usage",
                                Details: map[string]string{
                                        "message": event.Message,
                                },
                        }
                }</span>
        }

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "Resource Events",
                Status:  output.StatusPassed,
                Message: "No resource-related issues in events",
        }</span>
}

func (d *PodDiagnostic) checkDNSConfiguration(pod *corev1.Pod) output.CheckResult <span class="cov0" title="0">{
        if pod.Spec.DNSPolicy == corev1.DNSNone &amp;&amp; pod.Spec.DNSConfig == nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "DNS Configuration",
                        Status:     output.StatusFailed,
                        Message:    "DNS policy is None but no DNS config provided",
                        Suggestion: "Configure DNS settings when using DNSPolicy: None",
                        Details: map[string]string{
                                "dnsPolicy": string(pod.Spec.DNSPolicy),
                        },
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "DNS Configuration",
                Status:  output.StatusPassed,
                Message: fmt.Sprintf("DNS policy configured: %s", pod.Spec.DNSPolicy),
                Details: map[string]string{
                        "dnsPolicy": string(pod.Spec.DNSPolicy),
                },
        }</span>
}

func (d *PodDiagnostic) checkNetworkEvents(info *PodInfo) output.CheckResult <span class="cov0" title="0">{
        for _, event := range info.Events </span><span class="cov0" title="0">{
                if strings.Contains(event.Reason, "FailedCreatePodSandBox") ||
                        strings.Contains(event.Reason, "NetworkNotReady") ||
                        strings.Contains(event.Message, "CNI") </span><span class="cov0" title="0">{
                        return output.CheckResult{
                                Name:       "Network Events",
                                Status:     output.StatusFailed,
                                Message:    "Network-related errors detected",
                                Suggestion: "Check CNI plugin status and network configuration",
                                Details: map[string]string{
                                        "event": fmt.Sprintf("%s: %s", event.Reason, event.Message),
                                },
                        }
                }</span>
        }

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "Network Events",
                Status:  output.StatusPassed,
                Message: "No network-related issues in events",
        }</span>
}

// Helper functions

func getPodCondition(pod *corev1.Pod, conditionType corev1.PodConditionType) *corev1.PodCondition <span class="cov8" title="1">{
        for i := range pod.Status.Conditions </span><span class="cov8" title="1">{
                if pod.Status.Conditions[i].Type == conditionType </span><span class="cov8" title="1">{
                        return &amp;pod.Status.Conditions[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func formatConditionStatus(condition *corev1.PodCondition) string <span class="cov8" title="1">{
        if condition == nil </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>
        <span class="cov8" title="1">return string(condition.Status)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package pod provides diagnostic capabilities for Kubernetes pod-level issues.
//
// This package implements comprehensive checks for common pod problems including:
//   - Scheduling issues: insufficient resources, node taints, affinity constraints
//   - Image problems: pull errors, registry connectivity, authentication failures
//   - Runtime issues: CrashLoopBackOff, container startup failures, resource limits
//   - RBAC problems: permission validation for pods and service accounts
//   - Init container failures: startup errors, dependency issues, misconfigurations
//   - Network issues: DNS resolution, service connectivity, port accessibility
//
// The diagnostics help users identify root causes and provide actionable recommendations
// for resolving pod-related issues in Kubernetes clusters.
package pod

import (
        "context"
        "fmt"
        "strings"
        "time"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/apimachinery/pkg/watch"

        "kdebug/internal/client"
        "kdebug/internal/output"
)

// PodDiagnostic performs diagnostic checks for pod-level issues.
// It analyzes pod status, events, logs, and related resources to identify
// root causes and provide actionable recommendations for resolution.
type PodDiagnostic struct {
        // client provides access to the Kubernetes API
        client *client.KubernetesClient

        // output handles formatting and display of diagnostic results
        output *output.OutputManager
}

// DiagnosticConfig contains configuration options for pod diagnostics.
type DiagnosticConfig struct {
        // Namespace specifies the target namespace for diagnostics
        Namespace string

        // Checks specifies which diagnostic checks to run (empty = all checks)
        Checks []string

        // IncludeLogs enables log analysis for failed containers
        IncludeLogs bool

        // LogLines specifies number of recent log lines to analyze
        LogLines int

        // Timeout specifies maximum time for diagnostic operations
        Timeout time.Duration

        // Containers specifies which containers to analyze (empty = all containers)
        Containers []string
}

// PodInfo contains comprehensive information about a pod for diagnostics.
type PodInfo struct {
        Pod               *corev1.Pod
        Events            []corev1.Event
        ContainerLogs     map[string]string
        ServiceAccount    *corev1.ServiceAccount
        Secrets           []corev1.Secret
        ConfigMaps        []corev1.ConfigMap
        PersistentVolumes []corev1.PersistentVolume
        Node              *corev1.Node
}

// NewPodDiagnostic creates a new pod diagnostic instance.
func NewPodDiagnostic(client *client.KubernetesClient, output *output.OutputManager) *PodDiagnostic <span class="cov8" title="1">{
        return &amp;PodDiagnostic{
                client: client,
                output: output,
        }
}</span>

// DiagnosePod performs comprehensive diagnostics on a single pod.
func (d *PodDiagnostic) DiagnosePod(podName string, config DiagnosticConfig) (*output.DiagnosticReport, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), config.Timeout)
        defer cancel()

        // Gather pod information
        podInfo, err := d.gatherPodInfo(ctx, podName, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to gather pod information: %w", err)
        }</span>

        // Run diagnostic checks
        <span class="cov0" title="0">checks := d.runDiagnosticChecks(ctx, podInfo, config)

        // Calculate summary
        summary := d.calculateSummary(checks)

        // Create report
        report := &amp;output.DiagnosticReport{
                Target:    fmt.Sprintf("pod/%s", podName),
                Timestamp: time.Now().Format(time.RFC3339),
                Checks:    checks,
                Summary:   summary,
        }

        return report, nil</span>
}

// DiagnoseAllPods performs diagnostics on all pods in the specified namespace.
func (d *PodDiagnostic) DiagnoseAllPods(config DiagnosticConfig) (*output.DiagnosticReport, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), config.Timeout)
        defer cancel()

        // List all pods in namespace
        pods, err := d.client.Clientset.CoreV1().Pods(config.Namespace).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list pods: %w", err)
        }</span>

        <span class="cov0" title="0">if len(pods.Items) == 0 </span><span class="cov0" title="0">{
                return &amp;output.DiagnosticReport{
                        Target:    fmt.Sprintf("pods/namespace=%s", config.Namespace),
                        Timestamp: time.Now().Format(time.RFC3339),
                        Checks: []output.CheckResult{
                                {
                                        Name:    "Pod Discovery",
                                        Status:  "SKIPPED",
                                        Message: fmt.Sprintf("No pods found in namespace '%s'", config.Namespace),
                                },
                        },
                        Summary: output.Summary{Total: 1, Skipped: 1},
                }, nil
        }</span>

        <span class="cov0" title="0">var allChecks []output.CheckResult

        // Diagnose each pod
        for i := range pods.Items </span><span class="cov0" title="0">{
                pod := &amp;pods.Items[i]

                d.output.PrintInfo(fmt.Sprintf("Executing diagnostic analysis for pod '%s' in namespace '%s'", pod.Name, config.Namespace))

                podInfo, err := d.gatherPodInfoFromPod(ctx, pod, config)
                if err != nil </span><span class="cov0" title="0">{
                        d.output.PrintWarning(fmt.Sprintf("Failed to analyze pod %s: %v", pod.Name, err))
                        continue</span>
                }

                <span class="cov0" title="0">podChecks := d.runDiagnosticChecks(ctx, podInfo, config)

                // Prefix check names with pod name for clarity
                for j := range podChecks </span><span class="cov0" title="0">{
                        podChecks[j].Name = fmt.Sprintf("Pod %s: %s", pod.Name, podChecks[j].Name)
                }</span>

                <span class="cov0" title="0">allChecks = append(allChecks, podChecks...)</span>
        }

        // Calculate summary
        <span class="cov0" title="0">summary := d.calculateSummary(allChecks)

        // Create report
        report := &amp;output.DiagnosticReport{
                Target:    fmt.Sprintf("pods/namespace=%s", config.Namespace),
                Timestamp: time.Now().Format(time.RFC3339),
                Checks:    allChecks,
                Summary:   summary,
        }

        return report, nil</span>
}

// WatchPod watches a pod and re-runs diagnostics when changes occur.
func (d *PodDiagnostic) WatchPod(podName string, config DiagnosticConfig) error <span class="cov0" title="0">{
        d.output.PrintInfo(fmt.Sprintf("Watching pod '%s' for changes...", podName))

        watchlist := &amp;metav1.ListOptions{
                FieldSelector: fields.OneTermEqualSelector("metadata.name", podName).String(),
        }

        watcher, err := d.client.Clientset.CoreV1().Pods(config.Namespace).Watch(context.Background(), *watchlist)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to watch pod: %w", err)
        }</span>
        <span class="cov0" title="0">defer watcher.Stop()

        for event := range watcher.ResultChan() </span><span class="cov0" title="0">{
                switch event.Type </span>{
                case watch.Modified, watch.Added:<span class="cov0" title="0">
                        d.output.PrintInfo("Pod changed, re-running diagnostics...")

                        report, err := d.DiagnosePod(podName, config)
                        if err != nil </span><span class="cov0" title="0">{
                                d.output.PrintError(fmt.Sprintf("Failed to diagnose pod: %v", err), err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if err := d.output.PrintReport(report); err != nil </span><span class="cov0" title="0">{
                                d.output.PrintWarning(fmt.Sprintf("Failed to print report: %v", err))
                        }</span>
                        <span class="cov0" title="0">d.output.PrintInfo("Waiting for next change...")</span>

                case watch.Deleted:<span class="cov0" title="0">
                        d.output.PrintWarning("Pod was deleted")
                        return nil</span>

                case watch.Error:<span class="cov0" title="0">
                        d.output.PrintError("Watch error occurred", fmt.Errorf("watch error"))
                        return fmt.Errorf("watch error")</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// gatherPodInfo collects comprehensive information about a pod and related resources.
func (d *PodDiagnostic) gatherPodInfo(ctx context.Context, podName string, config DiagnosticConfig) (*PodInfo, error) <span class="cov0" title="0">{
        // Get the pod
        pod, err := d.client.Clientset.CoreV1().Pods(config.Namespace).Get(ctx, podName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pod: %w", err)
        }</span>

        <span class="cov0" title="0">return d.gatherPodInfoFromPod(ctx, pod, config)</span>
}

// gatherPodInfoFromPod collects information about a pod from an existing pod object.
func (d *PodDiagnostic) gatherPodInfoFromPod(ctx context.Context, pod *corev1.Pod, config DiagnosticConfig) (*PodInfo, error) <span class="cov0" title="0">{
        info := &amp;PodInfo{
                Pod:           pod,
                ContainerLogs: make(map[string]string),
        }

        // Get pod events
        events, err := d.client.Clientset.CoreV1().Events(config.Namespace).List(ctx, metav1.ListOptions{
                FieldSelector: fmt.Sprintf("involvedObject.name=%s,involvedObject.kind=Pod", pod.Name),
        })
        if err != nil </span><span class="cov0" title="0">{
                d.output.PrintWarning(fmt.Sprintf("Failed to get events for pod %s: %v", pod.Name, err))
        }</span> else<span class="cov0" title="0"> {
                info.Events = events.Items
        }</span>

        // Get service account if specified
        <span class="cov0" title="0">if pod.Spec.ServiceAccountName != "" </span><span class="cov0" title="0">{
                sa, err := d.client.Clientset.CoreV1().ServiceAccounts(config.Namespace).Get(ctx, pod.Spec.ServiceAccountName, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        d.output.PrintWarning(fmt.Sprintf("Failed to get service account %s: %v", pod.Spec.ServiceAccountName, err))
                }</span> else<span class="cov0" title="0"> {
                        info.ServiceAccount = sa
                }</span>
        }

        // Get node information
        <span class="cov0" title="0">if pod.Spec.NodeName != "" </span><span class="cov0" title="0">{
                node, err := d.client.Clientset.CoreV1().Nodes().Get(ctx, pod.Spec.NodeName, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        d.output.PrintWarning(fmt.Sprintf("Failed to get node %s: %v", pod.Spec.NodeName, err))
                }</span> else<span class="cov0" title="0"> {
                        info.Node = node
                }</span>
        }

        // Get container logs if requested and pod is failing
        <span class="cov0" title="0">if config.IncludeLogs &amp;&amp; d.isPodFailing(pod) </span><span class="cov0" title="0">{
                d.gatherContainerLogs(ctx, info, config)
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}

// gatherContainerLogs collects logs from containers in the pod.
func (d *PodDiagnostic) gatherContainerLogs(ctx context.Context, info *PodInfo, config DiagnosticConfig) <span class="cov0" title="0">{
        pod := info.Pod

        containers := config.Containers
        if len(containers) == 0 </span><span class="cov0" title="0">{
                // Get all containers if none specified
                for _, container := range pod.Spec.Containers </span><span class="cov0" title="0">{
                        containers = append(containers, container.Name)
                }</span>
                <span class="cov0" title="0">for _, container := range pod.Spec.InitContainers </span><span class="cov0" title="0">{
                        containers = append(containers, container.Name)
                }</span>
        }

        <span class="cov0" title="0">logOptions := &amp;corev1.PodLogOptions{
                TailLines: int64ptr(config.LogLines),
                Previous:  false, // Get current logs first
        }

        for _, containerName := range containers </span><span class="cov0" title="0">{
                logOptions.Container = containerName

                // Try current logs first
                logs, err := d.client.Clientset.CoreV1().Pods(config.Namespace).GetLogs(pod.Name, logOptions).Stream(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        // Try previous logs if current logs fail
                        logOptions.Previous = true
                        logs, err = d.client.Clientset.CoreV1().Pods(config.Namespace).GetLogs(pod.Name, logOptions).Stream(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                d.output.PrintWarning(fmt.Sprintf("Failed to get logs for container %s: %v", containerName, err))
                                continue</span>
                        }
                }

                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if closeErr := logs.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                // Log close error but don't fail the check
                                fmt.Printf("Warning: failed to close log stream: %v\n", closeErr)
                        }</span>
                }()

                <span class="cov0" title="0">buf := make([]byte, 2048)
                var logContent strings.Builder
                for </span><span class="cov0" title="0">{
                        n, err := logs.Read(buf)
                        if n &gt; 0 </span><span class="cov0" title="0">{
                                logContent.Write(buf[:n])
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov0" title="0">info.ContainerLogs[containerName] = logContent.String()

                // Reset for next container
                logOptions.Previous = false</span>
        }
}

// isPodFailing determines if a pod is in a failing state.
func (d *PodDiagnostic) isPodFailing(pod *corev1.Pod) bool <span class="cov8" title="1">{
        if pod.Status.Phase == corev1.PodFailed || pod.Status.Phase == corev1.PodPending </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check container statuses
        <span class="cov8" title="1">for _, status := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                if status.State.Waiting != nil </span><span class="cov8" title="1">{
                        reason := status.State.Waiting.Reason
                        if reason == "CrashLoopBackOff" || reason == "ImagePullBackOff" ||
                                reason == "ErrImagePull" || reason == "InvalidImageName" </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">if status.RestartCount &gt; 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// Helper function to create an int64 pointer
func int64ptr(i int) *int64 <span class="cov0" title="0">{
        val := int64(i)
        return &amp;val
}</span>

// calculateSummary computes summary statistics from diagnostic check results.
func (d *PodDiagnostic) calculateSummary(checks []output.CheckResult) output.Summary <span class="cov8" title="1">{
        summary := output.Summary{}

        for _, check := range checks </span><span class="cov8" title="1">{
                switch check.Status </span>{
                case "PASSED":<span class="cov8" title="1">
                        summary.Passed++</span>
                case "FAILED":<span class="cov8" title="1">
                        summary.Failed++</span>
                case "WARNING":<span class="cov8" title="1">
                        summary.Warnings++</span>
                case "SKIPPED":<span class="cov8" title="1">
                        summary.Skipped++</span>
                }
                <span class="cov8" title="1">summary.Total++</span>
        }

        <span class="cov8" title="1">return summary</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package service provides diagnostic capabilities for Kubernetes service-level issues.
//
// This package implements comprehensive checks for common service problems including:
//   - Service configuration: selector mismatches, port configuration, service types
//   - Endpoint health: backend pod availability, readiness, health status
//   - DNS resolution: service discovery, name resolution within cluster
//   - Connectivity issues: network policies, service mesh configuration
//   - Load balancing: endpoint distribution, session affinity
//
// The diagnostics help users identify root causes and provide actionable recommendations
// for resolving service-related networking issues in Kubernetes clusters.
package service

import (
        "context"
        "fmt"
        "strings"
        "time"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"

        "kdebug/internal/client"
        "kdebug/internal/output"
)

// ServiceDiagnostic performs diagnostic checks for service-level issues.
type ServiceDiagnostic struct {
        client *client.KubernetesClient
        output *output.OutputManager
}

// DiagnosticConfig contains configuration options for service diagnostics.
type DiagnosticConfig struct {
        Namespace     string
        Checks        []string
        TestDNS       bool
        AllNamespaces bool
        Timeout       time.Duration
        Verbose       bool
}

// ServiceInfo contains comprehensive information about a service and its health.
type ServiceInfo struct {
        Service     *corev1.Service
        Endpoints   *corev1.Endpoints
        BackendPods []*corev1.Pod
        Events      []corev1.Event
}

// NewServiceDiagnostic creates a new service diagnostic instance.
func NewServiceDiagnostic(kubeClient *client.KubernetesClient, outputMgr *output.OutputManager) *ServiceDiagnostic <span class="cov8" title="1">{
        return &amp;ServiceDiagnostic{
                client: kubeClient,
                output: outputMgr,
        }
}</span>

// DiagnoseService performs comprehensive diagnostics on a specific service.
func (sd *ServiceDiagnostic) DiagnoseService(ctx context.Context, serviceName string, config DiagnosticConfig) (*output.DiagnosticReport, error) <span class="cov0" title="0">{
        sd.output.PrintInfo(fmt.Sprintf("üîç Analyzing service: %s", serviceName))

        // Get service information
        serviceInfo, err := sd.getServiceInfo(ctx, serviceName, config.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get service information: %w", err)
        }</span>

        // Create diagnostic report
        <span class="cov0" title="0">report := &amp;output.DiagnosticReport{
                Target:    fmt.Sprintf("Service %s/%s", config.Namespace, serviceName),
                Timestamp: time.Now().Format(time.RFC3339),
                Checks:    []output.CheckResult{},
                Metadata: map[string]interface{}{
                        "resourceType": "Service",
                        "resourceName": serviceName,
                        "namespace":    config.Namespace,
                },
        }

        // Run diagnostic checks
        checks := []func(context.Context, *ServiceInfo, DiagnosticConfig) output.CheckResult{
                sd.checkServiceExists,
                sd.checkServiceConfiguration,
                sd.checkServiceSelector,
                sd.checkEndpointHealth,
                sd.checkPortConfiguration,
        }

        // Run checks
        for _, checkFunc := range checks </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil, ctx.Err()
                }</span>

                <span class="cov0" title="0">check := checkFunc(ctx, serviceInfo, config)
                report.Checks = append(report.Checks, check)</span>
        }

        // Calculate summary
        <span class="cov0" title="0">report.Summary = sd.calculateSummary(report.Checks)

        return report, nil</span>
}

// DiagnoseAllServices performs diagnostics on all services in the specified namespace(s).
func (sd *ServiceDiagnostic) DiagnoseAllServices(ctx context.Context, config DiagnosticConfig) ([]*output.DiagnosticReport, error) <span class="cov0" title="0">{
        var reports []*output.DiagnosticReport

        // Get list of services
        services, err := sd.getServiceList(ctx, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list services: %w", err)
        }</span>

        <span class="cov0" title="0">if len(services.Items) == 0 </span><span class="cov0" title="0">{
                sd.output.PrintInfo("No services found in the specified namespace(s)")
                return reports, nil
        }</span>

        <span class="cov0" title="0">sd.output.PrintInfo(fmt.Sprintf("üîç Analyzing %d services", len(services.Items)))

        // Diagnose each service
        for _, service := range services.Items </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return reports, ctx.Err()
                }</span>

                <span class="cov0" title="0">serviceConfig := config
                serviceConfig.Namespace = service.Namespace

                report, err := sd.DiagnoseService(ctx, service.Name, serviceConfig)
                if err != nil </span><span class="cov0" title="0">{
                        sd.output.PrintError("Failed to diagnose service", fmt.Errorf("service %s: %w", service.Name, err))
                        continue</span>
                }

                <span class="cov0" title="0">reports = append(reports, report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

// getServiceInfo retrieves comprehensive information about a service.
func (sd *ServiceDiagnostic) getServiceInfo(ctx context.Context, serviceName, namespace string) (*ServiceInfo, error) <span class="cov0" title="0">{
        info := &amp;ServiceInfo{}

        // Get service
        service, err := sd.client.Clientset.CoreV1().Services(namespace).Get(ctx, serviceName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get service: %w", err)
        }</span>
        <span class="cov0" title="0">info.Service = service

        // Get endpoints
        endpoints, err := sd.client.Clientset.CoreV1().Endpoints(namespace).Get(ctx, serviceName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                // Endpoints might not exist yet, which is not necessarily an error
                if !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get endpoints: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                info.Endpoints = endpoints
        }</span>

        // Get backend pods if service has selectors
        <span class="cov0" title="0">if len(service.Spec.Selector) &gt; 0 </span><span class="cov0" title="0">{
                selector := labels.SelectorFromSet(service.Spec.Selector)
                pods, err := sd.client.Clientset.CoreV1().Pods(namespace).List(ctx, metav1.ListOptions{
                        LabelSelector: selector.String(),
                })
                if err == nil </span><span class="cov0" title="0">{
                        for i := range pods.Items </span><span class="cov0" title="0">{
                                info.BackendPods = append(info.BackendPods, &amp;pods.Items[i])
                        }</span>
                }
        }

        // Get recent events
        <span class="cov0" title="0">events, err := sd.client.Clientset.CoreV1().Events(namespace).List(ctx, metav1.ListOptions{
                FieldSelector: fmt.Sprintf("involvedObject.name=%s,involvedObject.kind=Service", serviceName),
        })
        if err == nil </span><span class="cov0" title="0">{
                info.Events = events.Items
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}

// getServiceList retrieves a list of services based on the configuration.
func (sd *ServiceDiagnostic) getServiceList(ctx context.Context, config DiagnosticConfig) (*corev1.ServiceList, error) <span class="cov0" title="0">{
        if config.AllNamespaces </span><span class="cov0" title="0">{
                return sd.client.Clientset.CoreV1().Services("").List(ctx, metav1.ListOptions{})
        }</span>
        <span class="cov0" title="0">return sd.client.Clientset.CoreV1().Services(config.Namespace).List(ctx, metav1.ListOptions{})</span>
}

// checkServiceExists verifies that the service exists and is accessible.
func (sd *ServiceDiagnostic) checkServiceExists(ctx context.Context, info *ServiceInfo, config DiagnosticConfig) output.CheckResult <span class="cov8" title="1">{
        if info.Service == nil </span><span class="cov8" title="1">{
                return output.CheckResult{
                        Name:       "Service Existence",
                        Status:     output.StatusFailed,
                        Message:    "Service not found",
                        Suggestion: fmt.Sprintf("Create service or check service name in namespace %s", config.Namespace),
                        Details: map[string]string{
                                "namespace": config.Namespace,
                        },
                }
        }</span>

        <span class="cov8" title="1">return output.CheckResult{
                Name:    "Service Existence",
                Status:  output.StatusPassed,
                Message: fmt.Sprintf("Service '%s' exists and is accessible", info.Service.Name),
                Details: map[string]string{
                        "name":      info.Service.Name,
                        "namespace": info.Service.Namespace,
                        "type":      string(info.Service.Spec.Type),
                        "created":   info.Service.CreationTimestamp.Time.Format(time.RFC3339),
                },
        }</span>
}

// checkServiceConfiguration validates the service configuration.
func (sd *ServiceDiagnostic) checkServiceConfiguration(ctx context.Context, info *ServiceInfo, config DiagnosticConfig) output.CheckResult <span class="cov8" title="1">{
        if info.Service == nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:    "Service Configuration",
                        Status:  output.StatusSkipped,
                        Message: "Service not found, skipping configuration check",
                }
        }</span>

        <span class="cov8" title="1">service := info.Service
        issues := []string{}
        suggestions := []string{}

        // Check if service has ports configured
        if len(service.Spec.Ports) == 0 </span><span class="cov8" title="1">{
                issues = append(issues, "No ports configured")
                suggestions = append(suggestions, "Add port configuration to service spec")
        }</span>

        // Check for duplicate port names
        <span class="cov8" title="1">portNames := make(map[string]bool)
        for _, port := range service.Spec.Ports </span><span class="cov8" title="1">{
                if port.Name != "" </span><span class="cov8" title="1">{
                        if portNames[port.Name] </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("Duplicate port name: %s", port.Name))
                                suggestions = append(suggestions, "Ensure all port names are unique")
                        }</span>
                        <span class="cov8" title="1">portNames[port.Name] = true</span>
                }
        }

        // Check service type specific configuration
        <span class="cov8" title="1">switch service.Spec.Type </span>{
        case corev1.ServiceTypeLoadBalancer:<span class="cov0" title="0">
                if len(service.Status.LoadBalancer.Ingress) == 0 </span><span class="cov0" title="0">{
                        issues = append(issues, "LoadBalancer service has no external IP assigned")
                        suggestions = append(suggestions, "Check if load balancer controller is running and configured")
                }</span>
        case corev1.ServiceTypeNodePort:<span class="cov0" title="0">
                for _, port := range service.Spec.Ports </span><span class="cov0" title="0">{
                        if port.NodePort &lt; 30000 || port.NodePort &gt; 32767 </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("NodePort %d is outside valid range (30000-32767)", port.NodePort))
                                suggestions = append(suggestions, "Use NodePort in valid range or let Kubernetes assign one")
                        }</span>
                }
        case corev1.ServiceTypeExternalName:<span class="cov8" title="1">
                if service.Spec.ExternalName == "" </span><span class="cov8" title="1">{
                        issues = append(issues, "ExternalName service has no external name specified")
                        suggestions = append(suggestions, "Set spec.externalName to the target DNS name")
                }</span>
        }

        <span class="cov8" title="1">if len(issues) &gt; 0 </span><span class="cov8" title="1">{
                return output.CheckResult{
                        Name:       "Service Configuration",
                        Status:     output.StatusFailed,
                        Message:    fmt.Sprintf("Configuration issues found: %s", strings.Join(issues, ", ")),
                        Suggestion: strings.Join(suggestions, "; "),
                        Details: map[string]string{
                                "issues":      strings.Join(issues, ", "),
                                "serviceType": string(service.Spec.Type),
                                "portCount":   fmt.Sprintf("%d", len(service.Spec.Ports)),
                        },
                }
        }</span>

        <span class="cov8" title="1">return output.CheckResult{
                Name:    "Service Configuration",
                Status:  output.StatusPassed,
                Message: "Service configuration is valid",
                Details: map[string]string{
                        "serviceType": string(service.Spec.Type),
                        "portCount":   fmt.Sprintf("%d", len(service.Spec.Ports)),
                },
        }</span>
}

// checkServiceSelector validates the service selector and pod matching.
func (sd *ServiceDiagnostic) checkServiceSelector(ctx context.Context, info *ServiceInfo, config DiagnosticConfig) output.CheckResult <span class="cov8" title="1">{
        if info.Service == nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:    "Service Selector",
                        Status:  output.StatusSkipped,
                        Message: "Service not found, skipping selector check",
                }
        }</span>

        <span class="cov8" title="1">service := info.Service

        // ExternalName services don't have selectors
        if service.Spec.Type == corev1.ServiceTypeExternalName </span><span class="cov8" title="1">{
                return output.CheckResult{
                        Name:    "Service Selector",
                        Status:  output.StatusSkipped,
                        Message: "ExternalName service does not use selectors",
                }
        }</span>

        // Check if service has selectors
        <span class="cov8" title="1">if len(service.Spec.Selector) == 0 </span><span class="cov8" title="1">{
                return output.CheckResult{
                        Name:       "Service Selector",
                        Status:     output.StatusWarning,
                        Message:    "Service has no selector (headless service or manual endpoints)",
                        Suggestion: "If this should select pods, add appropriate selector labels",
                        Details: map[string]string{
                                "hasSelector": "false",
                        },
                }
        }</span>

        // Count matching pods
        <span class="cov8" title="1">matchingPods := len(info.BackendPods)
        readyPods := 0

        for _, pod := range info.BackendPods </span><span class="cov8" title="1">{
                if isPodReady(pod) </span><span class="cov8" title="1">{
                        readyPods++
                }</span>
        }

        <span class="cov8" title="1">if matchingPods == 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Service Selector",
                        Status:     output.StatusFailed,
                        Message:    "Service selector matches no pods",
                        Suggestion: "Check if pods exist with matching labels, or update service selector",
                        Details: map[string]string{
                                "matchingPods": "0",
                                "selector":     fmt.Sprintf("%v", service.Spec.Selector),
                        },
                }
        }</span>

        <span class="cov8" title="1">if readyPods == 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Service Selector",
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("Service selector matches %d pods but none are ready", matchingPods),
                        Suggestion: "Check pod readiness and health",
                        Details: map[string]string{
                                "matchingPods": fmt.Sprintf("%d", matchingPods),
                                "readyPods":    "0",
                                "selector":     fmt.Sprintf("%v", service.Spec.Selector),
                        },
                }
        }</span>

        <span class="cov8" title="1">return output.CheckResult{
                Name:    "Service Selector",
                Status:  output.StatusPassed,
                Message: fmt.Sprintf("Service selector matches %d pods (%d ready)", matchingPods, readyPods),
                Details: map[string]string{
                        "matchingPods": fmt.Sprintf("%d", matchingPods),
                        "readyPods":    fmt.Sprintf("%d", readyPods),
                        "selector":     fmt.Sprintf("%v", service.Spec.Selector),
                },
        }</span>
}

// checkEndpointHealth validates the health of service endpoints.
func (sd *ServiceDiagnostic) checkEndpointHealth(ctx context.Context, info *ServiceInfo, config DiagnosticConfig) output.CheckResult <span class="cov8" title="1">{
        if info.Service == nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:    "Endpoint Health",
                        Status:  output.StatusSkipped,
                        Message: "Service not found, skipping endpoint check",
                }
        }</span>

        // ExternalName services don't have endpoints
        <span class="cov8" title="1">if info.Service.Spec.Type == corev1.ServiceTypeExternalName </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:    "Endpoint Health",
                        Status:  output.StatusSkipped,
                        Message: "ExternalName service does not have endpoints",
                }
        }</span>

        // Check if endpoints exist
        <span class="cov8" title="1">if info.Endpoints == nil </span><span class="cov8" title="1">{
                return output.CheckResult{
                        Name:       "Endpoint Health",
                        Status:     output.StatusFailed,
                        Message:    "No endpoints found for service",
                        Suggestion: "Check if pods are running and ready, and if service selector is correct",
                        Details: map[string]string{
                                "hasEndpoints": "false",
                        },
                }
        }</span>

        // Count ready and not ready endpoints
        <span class="cov8" title="1">readyCount := 0
        notReadyCount := 0

        for _, subset := range info.Endpoints.Subsets </span><span class="cov8" title="1">{
                readyCount += len(subset.Addresses)
                notReadyCount += len(subset.NotReadyAddresses)
        }</span>

        <span class="cov8" title="1">totalEndpoints := readyCount + notReadyCount

        if totalEndpoints == 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Endpoint Health",
                        Status:     output.StatusFailed,
                        Message:    "Service has no endpoints",
                        Suggestion: "Check if pods are running and if service selector matches pod labels",
                        Details: map[string]string{
                                "readyEndpoints":    "0",
                                "notReadyEndpoints": "0",
                        },
                }
        }</span>

        <span class="cov8" title="1">if readyCount == 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Endpoint Health",
                        Status:     output.StatusFailed,
                        Message:    fmt.Sprintf("All %d endpoints are not ready", notReadyCount),
                        Suggestion: "Check pod readiness probes and application health",
                        Details: map[string]string{
                                "readyEndpoints":    "0",
                                "notReadyEndpoints": fmt.Sprintf("%d", notReadyCount),
                        },
                }
        }</span>

        <span class="cov8" title="1">if notReadyCount &gt; 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "Endpoint Health",
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("%d/%d endpoints are ready", readyCount, totalEndpoints),
                        Suggestion: "Some endpoints are not ready, check pod health",
                        Details: map[string]string{
                                "readyEndpoints":    fmt.Sprintf("%d", readyCount),
                                "notReadyEndpoints": fmt.Sprintf("%d", notReadyCount),
                        },
                }
        }</span>

        <span class="cov8" title="1">return output.CheckResult{
                Name:    "Endpoint Health",
                Status:  output.StatusPassed,
                Message: fmt.Sprintf("All %d endpoints are ready", readyCount),
                Details: map[string]string{
                        "readyEndpoints":    fmt.Sprintf("%d", readyCount),
                        "notReadyEndpoints": "0",
                },
        }</span>
}

// checkPortConfiguration validates service port configuration.
func (sd *ServiceDiagnostic) checkPortConfiguration(ctx context.Context, info *ServiceInfo, config DiagnosticConfig) output.CheckResult <span class="cov8" title="1">{
        if info.Service == nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:    "Port Configuration",
                        Status:  output.StatusSkipped,
                        Message: "Service not found, skipping port check",
                }
        }</span>

        <span class="cov8" title="1">service := info.Service
        issues := []string{}
        suggestions := []string{}

        // Check each port
        for _, port := range service.Spec.Ports </span><span class="cov8" title="1">{
                // Check for valid port numbers
                if port.Port &lt; 1 || port.Port &gt; 65535 </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Invalid service port: %d", port.Port))
                        suggestions = append(suggestions, "Use valid port numbers (1-65535)")
                }</span>

                <span class="cov8" title="1">if port.TargetPort.IntVal &lt; 1 || port.TargetPort.IntVal &gt; 65535 </span><span class="cov0" title="0">{
                        if port.TargetPort.StrVal == "" </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("Invalid target port: %d", port.TargetPort.IntVal))
                                suggestions = append(suggestions, "Use valid target port numbers (1-65535)")
                        }</span>
                }

                // Check protocol
                <span class="cov8" title="1">if port.Protocol != corev1.ProtocolTCP &amp;&amp; port.Protocol != corev1.ProtocolUDP &amp;&amp; port.Protocol != corev1.ProtocolSCTP </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("Invalid protocol: %s", port.Protocol))
                        suggestions = append(suggestions, "Use valid protocols (TCP, UDP, SCTP)")
                }</span>
        }

        <span class="cov8" title="1">if len(issues) &gt; 0 </span><span class="cov8" title="1">{
                return output.CheckResult{
                        Name:       "Port Configuration",
                        Status:     output.StatusFailed,
                        Message:    fmt.Sprintf("Port configuration issues: %s", strings.Join(issues, ", ")),
                        Suggestion: strings.Join(suggestions, "; "),
                        Details: map[string]string{
                                "issues":    strings.Join(issues, ", "),
                                "portCount": fmt.Sprintf("%d", len(service.Spec.Ports)),
                        },
                }
        }</span>

        <span class="cov8" title="1">return output.CheckResult{
                Name:    "Port Configuration",
                Status:  output.StatusPassed,
                Message: fmt.Sprintf("All %d port configurations are valid", len(service.Spec.Ports)),
                Details: map[string]string{
                        "portCount": fmt.Sprintf("%d", len(service.Spec.Ports)),
                },
        }</span>
}

// calculateSummary generates a summary of the diagnostic results.
func (sd *ServiceDiagnostic) calculateSummary(checks []output.CheckResult) output.Summary <span class="cov8" title="1">{
        passed := 0
        failed := 0
        warnings := 0
        skipped := 0

        for _, check := range checks </span><span class="cov8" title="1">{
                switch check.Status </span>{
                case output.StatusPassed:<span class="cov8" title="1">
                        passed++</span>
                case output.StatusFailed:<span class="cov8" title="1">
                        failed++</span>
                case output.StatusWarning:<span class="cov8" title="1">
                        warnings++</span>
                case output.StatusSkipped:<span class="cov8" title="1">
                        skipped++</span>
                }
        }

        <span class="cov8" title="1">return output.Summary{
                Total:    len(checks),
                Passed:   passed,
                Failed:   failed,
                Warnings: warnings,
                Skipped:  skipped,
        }</span>
}

// isPodReady checks if a pod is ready.
func isPodReady(pod *corev1.Pod) bool <span class="cov8" title="1">{
        for _, condition := range pod.Status.Conditions </span><span class="cov8" title="1">{
                if condition.Type == corev1.PodReady </span><span class="cov8" title="1">{
                        return condition.Status == corev1.ConditionTrue
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
