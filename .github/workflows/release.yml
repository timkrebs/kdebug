name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_call:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: false
        default: 'v0.1.0-dev'
        type: string
      create_release:
        description: 'Create GitHub release'
        required: false
        default: false
        type: boolean

  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: false
        default: 'v0.1.0-dev'
        type: string
      create_release:
        description: 'Create GitHub release'
        required: false
        default: false
        type: boolean

env:
  GO_VERSION: '1.24'  # Using Go 1.24 to match go.mod requirement

jobs:
  setup:
    name: Setup Release Info
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      create_release: ${{ steps.version.outputs.create_release }}
      is_tag: ${{ steps.version.outputs.is_tag }}
    steps:
    - name: Determine version and release type
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/v* ]]; then
          # Tagged release
          echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          echo "create_release=true" >> $GITHUB_OUTPUT
          echo "is_tag=true" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # Manual dispatch
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          echo "create_release=${{ github.event.inputs.create_release }}" >> $GITHUB_OUTPUT
          echo "is_tag=false" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event_name }}" == "workflow_call" ]]; then
          # Called from another workflow (CI success)
          echo "version=${{ inputs.version }}" >> $GITHUB_OUTPUT
          echo "create_release=${{ inputs.create_release }}" >> $GITHUB_OUTPUT
          echo "is_tag=false" >> $GITHUB_OUTPUT
        else
          # Default
          echo "version=v0.1.0-dev" >> $GITHUB_OUTPUT
          echo "create_release=false" >> $GITHUB_OUTPUT
          echo "is_tag=false" >> $GITHUB_OUTPUT
        fi

  test:
    name: Test Before Release
    runs-on: ubuntu-latest
    needs: [setup]
    # Skip tests for CI-triggered releases (tests already passed in CI)
    if: github.event_name != 'workflow_call'
    steps:
    - uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Run tests
      run: make test

    - name: Run integration tests
      run: |
        # Set up kind cluster
        go install sigs.k8s.io/kind@latest
        kind create cluster --name release-test --wait 60s
        
        # Create a simple test pod that should be healthy
        kubectl apply -f - <<EOF
        apiVersion: v1
        kind: Pod
        metadata:
          name: release-test-pod
          namespace: default
        spec:
          containers:
          - name: nginx
            image: nginx:1.21
            resources:
              requests:
                cpu: 10m
                memory: 32Mi
          restartPolicy: Never
        EOF
        
        # Wait for pod to be ready
        kubectl wait --for=condition=Ready pod/release-test-pod --timeout=60s
        
        # Build kdebug binary
        go build -o kdebug .
        
        # Test kdebug with healthy pod (should succeed)
        export KUBECONFIG=$HOME/.kube/config
        ./kdebug pod release-test-pod
        
        # Test cluster diagnostics (should succeed)  
        ./kdebug cluster
        
        # Cleanup
        kubectl delete pod release-test-pod --ignore-not-found=true
        kind delete cluster --name release-test

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [setup, test]
    # Always run if setup passes, test job may be skipped for CI-triggered releases
    if: always() && needs.setup.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped')
    permissions:
      contents: write
      packages: write
    steps:
    - uses: actions/checkout@v5
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Build cross-platform binaries
      run: |
        # Update version in Makefile
        sed -i "s/VERSION=0.1.0-dev/VERSION=${{ needs.setup.outputs.version }}/g" Makefile
        make build-all

    - name: Create checksums
      run: |
        cd bin
        sha256sum * > checksums.txt

    - name: Generate changelog
      id: changelog
      run: |
        if [ -f CHANGELOG.md ]; then
          # Extract changelog for this version
          awk '/^## \[${{ needs.setup.outputs.version }}\]/{flag=1; next} /^## \[/{flag=0} flag' CHANGELOG.md > release_notes.md
        else
          echo "Release ${{ needs.setup.outputs.version }}" > release_notes.md
          echo "" >> release_notes.md
          echo "### Changes" >> release_notes.md
          git log --pretty=format:"- %s" $(git describe --tags --abbrev=0 HEAD^)..HEAD >> release_notes.md
        fi

    - name: Create GitHub Release
      if: needs.setup.outputs.create_release == 'true'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.setup.outputs.version }}
        name: Release ${{ needs.setup.outputs.version }}
        body_path: release_notes.md
        files: |
          bin/kdebug-*
          bin/checksums.txt
        draft: false
        prerelease: ${{ contains(needs.setup.outputs.version, 'rc') || contains(needs.setup.outputs.version, 'beta') || contains(needs.setup.outputs.version, 'alpha') }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ secrets.DOCKERHUB_USERNAME }}/kdebug
        tags: |
          type=raw,value=${{ needs.setup.outputs.version }}
          type=raw,value=latest,enable=${{ needs.setup.outputs.is_tag == 'true' }}
          type=semver,pattern={{version}},value=${{ needs.setup.outputs.version }}
          type=semver,pattern={{major}}.{{minor}},value=${{ needs.setup.outputs.version }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v6
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ needs.setup.outputs.version }}

    - name: Update Homebrew Formula
      if: ${{ !contains(needs.setup.outputs.version, 'rc') && !contains(needs.setup.outputs.version, 'beta') && !contains(needs.setup.outputs.version, 'alpha') }}
      env:
        HOMEBREW_REPO_TOKEN: ${{ secrets.HOMEBREW_REPO_TOKEN }}
      run: |
        # Get the SHA256 hashes for the Darwin binaries
        DARWIN_AMD64_SHA=$(curl -sL https://github.com/timkrebs/kdebug/releases/download/${{ needs.setup.outputs.version }}/checksums.txt | grep kdebug-darwin-amd64 | cut -d' ' -f1)
        DARWIN_ARM64_SHA=$(curl -sL https://github.com/timkrebs/kdebug/releases/download/${{ needs.setup.outputs.version }}/checksums.txt | grep kdebug-darwin-arm64 | cut -d' ' -f1)
        
        # Clone the homebrew tap repository with PAT authentication
        git clone https://x-access-token:${{ secrets.HOMEBREW_REPO_TOKEN }}@github.com/timkrebs/homebrew-kdebug.git /tmp/homebrew-kdebug
        cd /tmp/homebrew-kdebug
        
        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Update the formula with new version and checksums
        cat > Formula/kdebug.rb << EOF
        class Kdebug < Formula
          desc "CLI tool that automatically diagnoses common Kubernetes issues and provides actionable suggestions"
          homepage "https://github.com/timkrebs/kdebug"
          version "${{ needs.setup.outputs.version }}"
          license "MIT"

          on_macos do
            if Hardware::CPU.intel?
              url "https://github.com/timkrebs/kdebug/releases/download/${{ needs.setup.outputs.version }}/kdebug-darwin-amd64"
              sha256 "${DARWIN_AMD64_SHA}"

              def install
                bin.install "kdebug-darwin-amd64" => "kdebug"
              end
            end
            if Hardware::CPU.arm?
              url "https://github.com/timkrebs/kdebug/releases/download/${{ needs.setup.outputs.version }}/kdebug-darwin-arm64"
              sha256 "${DARWIN_ARM64_SHA}"

              def install
                bin.install "kdebug-darwin-arm64" => "kdebug"
              end
            end
          end

          def caveats
            <<~EOS
              kdebug is a Kubernetes debugging tool. Make sure you have:
              - kubectl installed and configured
              - Access to a Kubernetes cluster
              
              Get started with:
                kdebug pod --help
                kdebug cluster --help
            EOS
          end

          test do
            system "#{bin}/kdebug", "--version"
            system "#{bin}/kdebug", "--help"
          end
        end
        EOF
        
        # Commit and push the updated formula
        git add Formula/kdebug.rb
        if git diff --cached --quiet; then
          echo "No changes to homebrew formula"
        else
          git commit -m "Update kdebug to ${{ needs.setup.outputs.version }}"
          git push origin main
          echo "✅ Updated Homebrew formula to ${{ needs.setup.outputs.version }}"
        fi

  notify:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [release]
    if: always()
    steps:
    - name: Notify on success
      if: needs.release.result == 'success'
      run: |
        echo "✅ Release ${{ github.ref_name }} was successful!"
        # Add notification logic here (Slack, Discord, etc.)

    - name: Notify on failure
      if: needs.release.result == 'failure'
      run: |
        echo "❌ Release ${{ github.ref_name }} failed!"
        # Add notification logic here (Slack, Discord, etc.)
