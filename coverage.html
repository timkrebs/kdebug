
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">kdebug/cmd/cluster.go (0.0%)</option>
				
				<option value="file1">kdebug/cmd/root.go (0.0%)</option>
				
				<option value="file2">kdebug/internal/client/client.go (73.0%)</option>
				
				<option value="file3">kdebug/internal/output/output.go (93.4%)</option>
				
				<option value="file4">kdebug/main.go (0.0%)</option>
				
				<option value="file5">kdebug/pkg/cluster/cluster.go (17.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "context"
        "fmt"
        "time"

        "kdebug/internal/client"
        "kdebug/internal/output"
        "kdebug/pkg/cluster"

        "github.com/spf13/cobra"
)

var (
        // Cluster command specific flags
        nodesOnly bool
        timeout   time.Duration
)

// clusterCmd represents the cluster command
var clusterCmd = &amp;cobra.Command{
        Use:   "cluster",
        Short: "Run comprehensive cluster health checks",
        Long: `Analyze the overall health of your Kubernetes cluster by checking:

‚Ä¢ API Server connectivity and response time
‚Ä¢ Node health and conditions (ready, memory pressure, disk pressure)
‚Ä¢ Control plane components (etcd, scheduler, controller manager)
‚Ä¢ DNS functionality and CoreDNS health
‚Ä¢ Basic cluster configuration

This command provides a quick overview of cluster-wide issues that might
affect workload deployment and operation.`,
        Example: `  # Run all cluster health checks
  kdebug cluster

  # Check only node health
  kdebug cluster --nodes-only

  # Output results as JSON
  kdebug cluster --output json

  # Verbose output with detailed information
  kdebug cluster --verbose

  # Set custom timeout for checks
  kdebug cluster --timeout 30s`,
        RunE: runClusterDiagnostics,
}

func init() <span class="cov0" title="0">{
        // Add cluster command to root
        rootCmd.AddCommand(clusterCmd)

        // Cluster-specific flags
        clusterCmd.Flags().BoolVar(&amp;nodesOnly, "nodes-only", false, "check only node health (skip control plane and DNS checks)")
        clusterCmd.Flags().DurationVar(&amp;timeout, "timeout", 30*time.Second, "timeout for cluster checks")
}</span>

// runClusterDiagnostics executes the cluster diagnostic checks
func runClusterDiagnostics(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // Initialize output manager
        outputMgr := output.NewOutputManager(outputFormat, verbose)

        // Print initial info
        if verbose </span><span class="cov0" title="0">{
                outputMgr.PrintInfo("Starting cluster diagnostics...")
                outputMgr.PrintInfo(fmt.Sprintf("Timeout: %v", timeout))
                if kubeconfig != "" </span><span class="cov0" title="0">{
                        outputMgr.PrintInfo(fmt.Sprintf("Using kubeconfig: %s", kubeconfig))
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Initialize Kubernetes client
        <span class="cov0" title="0">k8sClient, err := client.NewKubernetesClient(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                outputMgr.PrintError("Failed to initialize Kubernetes client", err)
                return err
        }</span>

        // Test basic connectivity first
        <span class="cov0" title="0">if err := k8sClient.TestConnection(ctx); err != nil </span><span class="cov0" title="0">{
                outputMgr.PrintError("Failed to connect to Kubernetes cluster", err)
                outputMgr.PrintInfo("Please check your kubeconfig and cluster connectivity")
                return err
        }</span>

        // Initialize cluster diagnostic
        <span class="cov0" title="0">clusterDiag := cluster.NewClusterDiagnostic(k8sClient, outputMgr)

        // Run diagnostics
        report, err := clusterDiag.RunDiagnostics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                outputMgr.PrintError("Failed to run cluster diagnostics", err)
                return err
        }</span>

        // Filter results if nodes-only flag is set
        <span class="cov0" title="0">if nodesOnly </span><span class="cov0" title="0">{
                report = filterNodeChecksOnly(report)
        }</span>

        // Print results
        <span class="cov0" title="0">if err := outputMgr.PrintReport(report); err != nil </span><span class="cov0" title="0">{
                outputMgr.PrintError("Failed to print diagnostic report", err)
                return err
        }</span>

        // Print additional information based on results
        <span class="cov0" title="0">if report.Summary.Failed &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println()
                outputMgr.PrintWarning("Some critical issues were found that may affect cluster functionality")
                outputMgr.PrintInfo("Review the failed checks above and follow the suggested actions")

                // Exit with non-zero code if there are critical failures
                return fmt.Errorf("cluster health check failed: %d critical issues found", report.Summary.Failed)
        }</span>

        <span class="cov0" title="0">if report.Summary.Warnings &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println()
                outputMgr.PrintWarning("Some warnings were found that should be addressed")
                outputMgr.PrintInfo("These issues may not immediately affect functionality but should be monitored")
        }</span>

        <span class="cov0" title="0">if report.Summary.Failed == 0 &amp;&amp; report.Summary.Warnings == 0 </span><span class="cov0" title="0">{
                fmt.Println()
                outputMgr.PrintSuccess("Cluster appears to be healthy! üéâ")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// filterNodeChecksOnly filters the report to include only node-related checks
func filterNodeChecksOnly(report *output.DiagnosticReport) *output.DiagnosticReport <span class="cov0" title="0">{
        var filteredChecks []output.CheckResult

        for _, check := range report.Checks </span><span class="cov0" title="0">{
                // Include connectivity check and node-related checks
                if check.Name == "API Server Connectivity" ||
                        containsAny(check.Name, []string{"Node", "node"}) </span><span class="cov0" title="0">{
                        filteredChecks = append(filteredChecks, check)
                }</span>
        }

        // Update the report
        <span class="cov0" title="0">newReport := *report
        newReport.Checks = filteredChecks
        newReport.Target = "cluster (nodes only)"

        // Recalculate summary
        newSummary := output.Summary{}
        for _, check := range filteredChecks </span><span class="cov0" title="0">{
                newSummary.Total++
                switch check.Status </span>{
                case output.StatusPassed:<span class="cov0" title="0">
                        newSummary.Passed++</span>
                case output.StatusFailed:<span class="cov0" title="0">
                        newSummary.Failed++</span>
                case output.StatusWarning:<span class="cov0" title="0">
                        newSummary.Warnings++</span>
                case output.StatusSkipped:<span class="cov0" title="0">
                        newSummary.Skipped++</span>
                }
        }
        <span class="cov0" title="0">newReport.Summary = newSummary

        return &amp;newReport</span>
}

// containsAny checks if the string contains any of the given substrings
func containsAny(s string, substrings []string) bool <span class="cov0" title="0">{
        for _, substr := range substrings </span><span class="cov0" title="0">{
                if len(s) &gt;= len(substr) </span><span class="cov0" title="0">{
                        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright ¬© 2025 NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cmd

import (
        "os"

        "github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "kdebug",
        Short: "A CLI tool that automatically diagnoses common Kubernetes issues",
        Long: `kdebug is a diagnostic tool for Kubernetes clusters that automatically
identifies common issues and provides actionable suggestions.

Think of it as a "doctor" for Kubernetes clusters (like 'brew doctor', but for K8s).
Instead of manually digging through kubectl describe outputs and events, kdebug 
runs a series of checks and gives clear guidance on what's wrong and how to fix it.

Examples:
  kdebug cluster                           # Run cluster-wide health checks
  kdebug pod myapp-123 -n production      # Debug a specific pod
  kdebug service myservice                 # Check service and endpoints
  kdebug dns                               # Test DNS resolution`,
        Version: "0.1.0-dev",
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

var (
        // Global flags
        kubeconfig   string
        namespace    string
        outputFormat string
        verbose      bool
)

func init() <span class="cov0" title="0">{
        // Global persistent flags that apply to all commands
        rootCmd.PersistentFlags().StringVar(&amp;kubeconfig, "kubeconfig", "", "path to kubeconfig file (defaults to $HOME/.kube/config)")
        rootCmd.PersistentFlags().StringVarP(&amp;namespace, "namespace", "n", "default", "Kubernetes namespace")
        rootCmd.PersistentFlags().StringVarP(&amp;outputFormat, "output", "o", "table", "output format: table, json, yaml")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "verbose output for debugging")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package client

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/homedir"
)

// KubernetesClient wraps the Kubernetes clientset with additional metadata
type KubernetesClient struct {
        Clientset *kubernetes.Clientset
        Config    *rest.Config
        Context   string
}

// NewKubernetesClient creates a new Kubernetes client
func NewKubernetesClient(kubeconfig string) (*KubernetesClient, error) <span class="cov8" title="1">{
        var config *rest.Config
        var err error

        if kubeconfig == "" </span><span class="cov8" title="1">{
                // Try in-cluster config first
                config, err = rest.InClusterConfig()
                if err != nil </span><span class="cov8" title="1">{
                        // Fall back to kubeconfig file
                        kubeconfig = getDefaultKubeconfigPath()
                }</span>
        }

        <span class="cov8" title="1">if config == nil </span><span class="cov8" title="1">{
                // Load config from kubeconfig file
                config, err = clientcmd.BuildConfigFromFlags("", kubeconfig)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to load kubeconfig: %w", err)
                }</span>
        }

        // Create clientset
        <span class="cov8" title="1">clientset, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Kubernetes client: %w", err)
        }</span>

        // Get current context
        <span class="cov8" title="1">context, err := getCurrentContext(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                context = "unknown"
        }</span>

        <span class="cov8" title="1">return &amp;KubernetesClient{
                Clientset: clientset,
                Config:    config,
                Context:   context,
        }, nil</span>
}

// TestConnection tests the connection to the Kubernetes cluster
func (k *KubernetesClient) TestConnection(ctx context.Context) error <span class="cov8" title="1">{
        _, err := k.Clientset.Discovery().ServerVersion()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to connect to Kubernetes cluster: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetClusterInfo returns basic cluster information
func (k *KubernetesClient) GetClusterInfo(ctx context.Context) (map[string]string, error) <span class="cov0" title="0">{
        version, err := k.Clientset.Discovery().ServerVersion()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get server version: %w", err)
        }</span>

        <span class="cov0" title="0">info := map[string]string{
                "context":    k.Context,
                "server":     k.Config.Host,
                "version":    version.String(),
                "gitVersion": version.GitVersion,
                "platform":   version.Platform,
        }

        return info, nil</span>
}

// getDefaultKubeconfigPath returns the default kubeconfig path
func getDefaultKubeconfigPath() string <span class="cov8" title="1">{
        if home := homedir.HomeDir(); home != "" </span><span class="cov8" title="1">{
                return filepath.Join(home, ".kube", "config")
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// getCurrentContext returns the current context from kubeconfig
func getCurrentContext(kubeconfig string) (string, error) <span class="cov8" title="1">{
        if kubeconfig == "" </span><span class="cov8" title="1">{
                kubeconfig = getDefaultKubeconfigPath()
        }</span>

        <span class="cov8" title="1">if _, err := os.Stat(kubeconfig); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">config, err := clientcmd.LoadFromFile(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return config.CurrentContext, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package output

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "github.com/olekukonko/tablewriter"
        "gopkg.in/yaml.v3"
)

// OutputFormat represents the supported output formats
type OutputFormat string

const (
        FormatTable OutputFormat = "table"
        FormatJSON  OutputFormat = "json"
        FormatYAML  OutputFormat = "yaml"
)

// CheckResult represents a single diagnostic check result
type CheckResult struct {
        Name       string            `json:"name" yaml:"name"`
        Status     CheckStatus       `json:"status" yaml:"status"`
        Message    string            `json:"message" yaml:"message"`
        Suggestion string            `json:"suggestion,omitempty" yaml:"suggestion,omitempty"`
        Details    map[string]string `json:"details,omitempty" yaml:"details,omitempty"`
        Error      string            `json:"error,omitempty" yaml:"error,omitempty"`
}

// CheckStatus represents the status of a check
type CheckStatus string

const (
        StatusPassed  CheckStatus = "PASSED"
        StatusFailed  CheckStatus = "FAILED"
        StatusWarning CheckStatus = "WARNING"
        StatusSkipped CheckStatus = "SKIPPED"
)

// DiagnosticReport represents a complete diagnostic report
type DiagnosticReport struct {
        Target      string                 `json:"target" yaml:"target"`
        Timestamp   string                 `json:"timestamp" yaml:"timestamp"`
        ClusterInfo map[string]string      `json:"cluster_info" yaml:"cluster_info"`
        Summary     Summary                `json:"summary" yaml:"summary"`
        Checks      []CheckResult          `json:"checks" yaml:"checks"`
        Metadata    map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty"`
}

// Summary provides a summary of check results
type Summary struct {
        Total    int `json:"total" yaml:"total"`
        Passed   int `json:"passed" yaml:"passed"`
        Failed   int `json:"failed" yaml:"failed"`
        Warnings int `json:"warnings" yaml:"warnings"`
        Skipped  int `json:"skipped" yaml:"skipped"`
}

// OutputManager handles formatting and outputting results
type OutputManager struct {
        Format  OutputFormat
        Verbose bool
}

// NewOutputManager creates a new output manager
func NewOutputManager(format string, verbose bool) *OutputManager <span class="cov8" title="1">{
        outputFormat := OutputFormat(strings.ToLower(format))
        
        // Validate format and default to table if invalid
        switch outputFormat </span>{
        case FormatTable, FormatJSON, FormatYAML:<span class="cov8" title="1"></span>
                // Valid format
        default:<span class="cov8" title="1">
                outputFormat = FormatTable</span>
        }
        
        <span class="cov8" title="1">return &amp;OutputManager{
                Format:  outputFormat,
                Verbose: verbose,
        }</span>
}

// PrintReport prints the diagnostic report in the specified format
func (o *OutputManager) PrintReport(report *DiagnosticReport) error <span class="cov8" title="1">{
        switch o.Format </span>{
        case FormatJSON:<span class="cov8" title="1">
                return o.printJSON(report)</span>
        case FormatYAML:<span class="cov8" title="1">
                return o.printYAML(report)</span>
        case FormatTable:<span class="cov8" title="1">
                fallthrough</span>
        default:<span class="cov8" title="1">
                return o.printTable(report)</span>
        }
}

// printJSON prints the report as JSON
func (o *OutputManager) printJSON(report *DiagnosticReport) error <span class="cov8" title="1">{
        encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(report)
}</span>

// printYAML prints the report as YAML
func (o *OutputManager) printYAML(report *DiagnosticReport) error <span class="cov8" title="1">{
        encoder := yaml.NewEncoder(os.Stdout)
        defer encoder.Close()
        return encoder.Encode(report)
}</span>

// printTable prints the report as a formatted table
func (o *OutputManager) printTable(report *DiagnosticReport) error <span class="cov8" title="1">{
        // Print header
        fmt.Printf("üîç Analyzing %s\n\n", report.Target)

        // Print cluster info if verbose
        if o.Verbose &amp;&amp; len(report.ClusterInfo) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Println("üìã Cluster Information:")
                for key, value := range report.ClusterInfo </span><span class="cov8" title="1">{
                        fmt.Printf("   %s: %s\n", key, value)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Create table for checks
        <span class="cov8" title="1">table := tablewriter.NewWriter(os.Stdout)
        table.SetHeader([]string{"Check", "Status", "Message"})
        table.SetBorder(false)
        table.SetHeaderAlignment(tablewriter.ALIGN_LEFT)
        table.SetAlignment(tablewriter.ALIGN_LEFT)
        table.SetCenterSeparator("")
        table.SetColumnSeparator("")
        table.SetRowSeparator("")
        table.SetHeaderLine(false)
        table.SetTablePadding("\t")
        table.SetNoWhiteSpace(true)

        // Add check results to table
        for _, check := range report.Checks </span><span class="cov8" title="1">{
                status := o.formatStatus(check.Status)
                message := check.Message

                // Truncate long messages for table display
                if len(message) &gt; 80 &amp;&amp; !o.Verbose </span><span class="cov0" title="0">{
                        message = message[:77] + "..."
                }</span>

                <span class="cov8" title="1">table.Append([]string{check.Name, status, message})

                // Print suggestion and details if failed and verbose
                if (check.Status == StatusFailed || check.Status == StatusWarning) &amp;&amp; o.Verbose </span><span class="cov8" title="1">{
                        if check.Suggestion != "" </span><span class="cov8" title="1">{
                                table.Append([]string{"", "üí°", "Suggestion: " + check.Suggestion})
                        }</span>
                        <span class="cov8" title="1">if check.Error != "" </span><span class="cov0" title="0">{
                                table.Append([]string{"", "‚ùå", "Error: " + check.Error})
                        }</span>
                        <span class="cov8" title="1">for key, value := range check.Details </span><span class="cov8" title="1">{
                                table.Append([]string{"", "üìÑ", fmt.Sprintf("%s: %s", key, value)})
                        }</span>
                }
        }

        <span class="cov8" title="1">table.Render()

        // Print summary
        fmt.Printf("\nüìä Summary: %d/%d checks passed", report.Summary.Passed, report.Summary.Total)
        if report.Summary.Failed &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf(", %d failed", report.Summary.Failed)
        }</span>
        <span class="cov8" title="1">if report.Summary.Warnings &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf(", %d warnings", report.Summary.Warnings)
        }</span>
        <span class="cov8" title="1">if report.Summary.Skipped &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf(", %d skipped", report.Summary.Skipped)
        }</span>
        <span class="cov8" title="1">fmt.Println()

        // Print failed checks summary
        if !o.Verbose &amp;&amp; (report.Summary.Failed &gt; 0 || report.Summary.Warnings &gt; 0) </span><span class="cov8" title="1">{
                fmt.Println("\nüéØ Issues Found:")
                for _, check := range report.Checks </span><span class="cov8" title="1">{
                        if check.Status == StatusFailed || check.Status == StatusWarning </span><span class="cov8" title="1">{
                                fmt.Printf("   %s %s\n", o.formatStatus(check.Status), check.Name)
                                if check.Suggestion != "" </span><span class="cov8" title="1">{
                                        fmt.Printf("      üí° %s\n", check.Suggestion)
                                }</span>
                        }
                }
                <span class="cov8" title="1">fmt.Println("\nRun with --verbose for detailed information")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// formatStatus returns a colored status indicator
func (o *OutputManager) formatStatus(status CheckStatus) string <span class="cov8" title="1">{
        switch status </span>{
        case StatusPassed:<span class="cov8" title="1">
                return "‚úÖ"</span>
        case StatusFailed:<span class="cov8" title="1">
                return "‚ùå"</span>
        case StatusWarning:<span class="cov8" title="1">
                return "‚ö†Ô∏è"</span>
        case StatusSkipped:<span class="cov8" title="1">
                return "‚è≠Ô∏è"</span>
        default:<span class="cov8" title="1">
                return "‚ùì"</span>
        }
}

// PrintError prints an error message
func (o *OutputManager) PrintError(message string, err error) <span class="cov8" title="1">{
        fmt.Fprintf(os.Stderr, "‚ùå Error: %s\n", message)
        if err != nil </span><span class="cov0" title="0">{
                if o.Verbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "   Details: %v\n", err)
                }</span>
        }
}

// PrintWarning prints a warning message
func (o *OutputManager) PrintWarning(message string) <span class="cov8" title="1">{
        fmt.Printf("‚ö†Ô∏è  Warning: %s\n", message)
}</span>

// PrintInfo prints an informational message
func (o *OutputManager) PrintInfo(message string) <span class="cov8" title="1">{
        fmt.Printf("‚ÑπÔ∏è  %s\n", message)
}</span>

// PrintSuccess prints a success message
func (o *OutputManager) PrintSuccess(message string) <span class="cov8" title="1">{
        fmt.Printf("‚úÖ %s\n", message)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright ¬© 2025 NAME HERE &lt;EMAIL ADDRESS&gt;

*/
package main

import "kdebug/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package cluster

import (
        "context"
        "fmt"
        "time"

        "kdebug/internal/client"
        "kdebug/internal/output"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ClusterDiagnostic handles cluster-level health checks
type ClusterDiagnostic struct {
        client *client.KubernetesClient
        output *output.OutputManager
}

// NewClusterDiagnostic creates a new cluster diagnostic
func NewClusterDiagnostic(k8sClient *client.KubernetesClient, outputMgr *output.OutputManager) *ClusterDiagnostic <span class="cov8" title="1">{
        return &amp;ClusterDiagnostic{
                client: k8sClient,
                output: outputMgr,
        }
}</span>

// RunDiagnostics runs all cluster-level diagnostic checks
func (c *ClusterDiagnostic) RunDiagnostics(ctx context.Context) (*output.DiagnosticReport, error) <span class="cov0" title="0">{
        // Get cluster info
        clusterInfo, err := c.client.GetClusterInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cluster info: %w", err)
        }</span>

        // Initialize report
        <span class="cov0" title="0">report := &amp;output.DiagnosticReport{
                Target:      "cluster",
                Timestamp:   time.Now().Format(time.RFC3339),
                ClusterInfo: clusterInfo,
                Checks:      []output.CheckResult{},
                Metadata:    make(map[string]interface{}),
        }

        // Run connectivity check
        connectivityResult := c.checkConnectivity(ctx)
        report.Checks = append(report.Checks, connectivityResult)

        // Run node health checks
        nodeResults := c.checkNodeHealth(ctx)
        report.Checks = append(report.Checks, nodeResults...)

        // Run control plane checks
        controlPlaneResults := c.checkControlPlane(ctx)
        report.Checks = append(report.Checks, controlPlaneResults...)

        // Run DNS checks
        dnsResult := c.checkDNS(ctx)
        report.Checks = append(report.Checks, dnsResult)

        // Calculate summary
        report.Summary = c.calculateSummary(report.Checks)

        return report, nil</span>
}

// checkConnectivity tests basic connectivity to the Kubernetes API server
func (c *ClusterDiagnostic) checkConnectivity(ctx context.Context) output.CheckResult <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.TestConnection(ctx)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "API Server Connectivity",
                        Status:     output.StatusFailed,
                        Message:    "Failed to connect to Kubernetes API server",
                        Error:      err.Error(),
                        Suggestion: "Check your kubeconfig file and ensure the cluster is accessible",
                }
        }</span>

        <span class="cov0" title="0">details := map[string]string{
                "response_time": duration.String(),
                "server":        c.client.Config.Host,
        }

        message := fmt.Sprintf("Successfully connected to API server (response time: %v)", duration)
        if duration &gt; 5*time.Second </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "API Server Connectivity",
                        Status:     output.StatusWarning,
                        Message:    message + " - slow response",
                        Details:    details,
                        Suggestion: "API server response is slow, check network connectivity",
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "API Server Connectivity",
                Status:  output.StatusPassed,
                Message: message,
                Details: details,
        }</span>
}

// checkNodeHealth checks the health status of all nodes
func (c *ClusterDiagnostic) checkNodeHealth(ctx context.Context) []output.CheckResult <span class="cov0" title="0">{
        var results []output.CheckResult

        nodes, err := c.client.Clientset.CoreV1().Nodes().List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return []output.CheckResult{{
                        Name:       "Node Health",
                        Status:     output.StatusFailed,
                        Message:    "Failed to list cluster nodes",
                        Error:      err.Error(),
                        Suggestion: "Check RBAC permissions for node access",
                }}
        }</span>

        <span class="cov0" title="0">if len(nodes.Items) == 0 </span><span class="cov0" title="0">{
                return []output.CheckResult{{
                        Name:       "Node Health",
                        Status:     output.StatusFailed,
                        Message:    "No nodes found in cluster",
                        Suggestion: "Ensure cluster has at least one node",
                }}
        }</span>

        // Overall node summary
        <span class="cov0" title="0">totalNodes := len(nodes.Items)
        readyNodes := 0
        var problematicNodes []string

        // Check each node
        for _, node := range nodes.Items </span><span class="cov0" title="0">{
                nodeReady := false
                var nodeIssues []string

                // Check node conditions
                for _, condition := range node.Status.Conditions </span><span class="cov0" title="0">{
                        switch condition.Type </span>{
                        case corev1.NodeReady:<span class="cov0" title="0">
                                if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        nodeReady = true
                                        readyNodes++
                                }</span> else<span class="cov0" title="0"> {
                                        nodeIssues = append(nodeIssues, "NotReady")
                                }</span>
                        case corev1.NodeMemoryPressure:<span class="cov0" title="0">
                                if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        nodeIssues = append(nodeIssues, "MemoryPressure")
                                }</span>
                        case corev1.NodeDiskPressure:<span class="cov0" title="0">
                                if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        nodeIssues = append(nodeIssues, "DiskPressure")
                                }</span>
                        case corev1.NodePIDPressure:<span class="cov0" title="0">
                                if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        nodeIssues = append(nodeIssues, "PIDPressure")
                                }</span>
                        case corev1.NodeNetworkUnavailable:<span class="cov0" title="0">
                                if condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        nodeIssues = append(nodeIssues, "NetworkUnavailable")
                                }</span>
                        }
                }

                // Create individual node check if there are issues
                <span class="cov0" title="0">if len(nodeIssues) &gt; 0 </span><span class="cov0" title="0">{
                        problematicNodes = append(problematicNodes, node.Name)

                        status := output.StatusWarning
                        if !nodeReady </span><span class="cov0" title="0">{
                                status = output.StatusFailed
                        }</span>

                        <span class="cov0" title="0">results = append(results, output.CheckResult{
                                Name:    fmt.Sprintf("Node: %s", node.Name),
                                Status:  status,
                                Message: fmt.Sprintf("Node has issues: %v", nodeIssues),
                                Details: map[string]string{
                                        "node_name": node.Name,
                                        "issues":    fmt.Sprintf("%v", nodeIssues),
                                        "ready":     fmt.Sprintf("%t", nodeReady),
                                },
                                Suggestion: c.getNodeSuggestion(nodeIssues),
                        })</span>
                }
        }

        // Overall node health summary
        <span class="cov0" title="0">if readyNodes == totalNodes &amp;&amp; len(problematicNodes) == 0 </span><span class="cov0" title="0">{
                results = append([]output.CheckResult{{
                        Name:    "Node Health Overview",
                        Status:  output.StatusPassed,
                        Message: fmt.Sprintf("All %d nodes are healthy and ready", totalNodes),
                        Details: map[string]string{
                                "total_nodes": fmt.Sprintf("%d", totalNodes),
                                "ready_nodes": fmt.Sprintf("%d", readyNodes),
                        },
                }}, results...)
        }</span> else<span class="cov0" title="0"> {
                status := output.StatusWarning
                if readyNodes == 0 </span><span class="cov0" title="0">{
                        status = output.StatusFailed
                }</span>

                <span class="cov0" title="0">results = append([]output.CheckResult{{
                        Name:    "Node Health Overview",
                        Status:  status,
                        Message: fmt.Sprintf("%d/%d nodes ready, %d nodes with issues", readyNodes, totalNodes, len(problematicNodes)),
                        Details: map[string]string{
                                "total_nodes":       fmt.Sprintf("%d", totalNodes),
                                "ready_nodes":       fmt.Sprintf("%d", readyNodes),
                                "problematic_nodes": fmt.Sprintf("%v", problematicNodes),
                        },
                        Suggestion: "Check individual node issues below and address node problems",
                }}, results...)</span>
        }

        <span class="cov0" title="0">return results</span>
}

// checkControlPlane checks the health of control plane components
func (c *ClusterDiagnostic) checkControlPlane(ctx context.Context) []output.CheckResult <span class="cov0" title="0">{
        var results []output.CheckResult

        // Check if we can access system namespaces (indicates control plane access)
        systemPods, err := c.client.Clientset.CoreV1().Pods("kube-system").List(ctx, metav1.ListOptions{
                LabelSelector: "component in (etcd,kube-apiserver,kube-controller-manager,kube-scheduler)",
        })

        if err != nil </span><span class="cov0" title="0">{
                return []output.CheckResult{{
                        Name:       "Control Plane Health",
                        Status:     output.StatusWarning,
                        Message:    "Unable to access control plane components",
                        Error:      err.Error(),
                        Suggestion: "Check RBAC permissions for kube-system namespace access",
                }}
        }</span>

        <span class="cov0" title="0">if len(systemPods.Items) == 0 </span><span class="cov0" title="0">{
                return []output.CheckResult{{
                        Name:       "Control Plane Health",
                        Status:     output.StatusWarning,
                        Message:    "No control plane components found (might be managed cluster)",
                        Suggestion: "This might be a managed cluster (EKS, GKE, AKS) where control plane is managed",
                }}
        }</span>

        // Group pods by component
        <span class="cov0" title="0">components := make(map[string][]corev1.Pod)
        for _, pod := range systemPods.Items </span><span class="cov0" title="0">{
                if component, exists := pod.Labels["component"]; exists </span><span class="cov0" title="0">{
                        components[component] = append(components[component], pod)
                }</span>
        }

        // Check each component
        <span class="cov0" title="0">allHealthy := true
        for component, pods := range components </span><span class="cov0" title="0">{
                runningPods := 0
                for _, pod := range pods </span><span class="cov0" title="0">{
                        if pod.Status.Phase == corev1.PodRunning </span><span class="cov0" title="0">{
                                runningPods++
                        }</span>
                }

                <span class="cov0" title="0">status := output.StatusPassed
                message := fmt.Sprintf("%s: %d/%d pods running", component, runningPods, len(pods))

                if runningPods == 0 </span><span class="cov0" title="0">{
                        status = output.StatusFailed
                        allHealthy = false
                        message = fmt.Sprintf("%s: no pods running", component)
                }</span> else<span class="cov0" title="0"> if runningPods &lt; len(pods) </span><span class="cov0" title="0">{
                        status = output.StatusWarning
                        allHealthy = false
                }</span>

                <span class="cov0" title="0">results = append(results, output.CheckResult{
                        Name:    fmt.Sprintf("Control Plane: %s", component),
                        Status:  status,
                        Message: message,
                        Details: map[string]string{
                                "component":    component,
                                "running_pods": fmt.Sprintf("%d", runningPods),
                                "total_pods":   fmt.Sprintf("%d", len(pods)),
                        },
                        Suggestion: c.getControlPlaneSuggestion(component, runningPods, len(pods)),
                })</span>
        }

        // Overall control plane summary
        <span class="cov0" title="0">overallStatus := output.StatusPassed
        summaryMessage := "Control plane components are healthy"
        if !allHealthy </span><span class="cov0" title="0">{
                overallStatus = output.StatusWarning
                summaryMessage = "Some control plane components have issues"
        }</span>

        <span class="cov0" title="0">results = append([]output.CheckResult{{
                Name:    "Control Plane Overview",
                Status:  overallStatus,
                Message: summaryMessage,
                Details: map[string]string{
                        "components_found": fmt.Sprintf("%d", len(components)),
                },
        }}, results...)

        return results</span>
}

// checkDNS performs basic DNS functionality check
func (c *ClusterDiagnostic) checkDNS(ctx context.Context) output.CheckResult <span class="cov0" title="0">{
        // Check CoreDNS/kube-dns pods
        dnsPods, err := c.client.Clientset.CoreV1().Pods("kube-system").List(ctx, metav1.ListOptions{
                LabelSelector: "k8s-app in (kube-dns,coredns)",
        })

        if err != nil </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "DNS Health",
                        Status:     output.StatusFailed,
                        Message:    "Failed to check DNS pods",
                        Error:      err.Error(),
                        Suggestion: "Check RBAC permissions for kube-system namespace",
                }
        }</span>

        <span class="cov0" title="0">if len(dnsPods.Items) == 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "DNS Health",
                        Status:     output.StatusFailed,
                        Message:    "No DNS pods found in kube-system namespace",
                        Suggestion: "Install CoreDNS or kube-dns for cluster DNS resolution",
                }
        }</span>

        <span class="cov0" title="0">runningDNSPods := 0
        var dnsIssues []string

        for _, pod := range dnsPods.Items </span><span class="cov0" title="0">{
                if pod.Status.Phase == corev1.PodRunning </span><span class="cov0" title="0">{
                        runningDNSPods++
                }</span> else<span class="cov0" title="0"> {
                        dnsIssues = append(dnsIssues, fmt.Sprintf("%s: %s", pod.Name, pod.Status.Phase))
                }</span>
        }

        <span class="cov0" title="0">details := map[string]string{
                "dns_pods_running": fmt.Sprintf("%d", runningDNSPods),
                "dns_pods_total":   fmt.Sprintf("%d", len(dnsPods.Items)),
        }

        if runningDNSPods == 0 </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "DNS Health",
                        Status:     output.StatusFailed,
                        Message:    "No DNS pods are running",
                        Details:    details,
                        Suggestion: "Check DNS pod logs and restart DNS deployment",
                }
        }</span>

        <span class="cov0" title="0">if runningDNSPods &lt; len(dnsPods.Items) </span><span class="cov0" title="0">{
                return output.CheckResult{
                        Name:       "DNS Health",
                        Status:     output.StatusWarning,
                        Message:    fmt.Sprintf("DNS partially functional: %d/%d pods running", runningDNSPods, len(dnsPods.Items)),
                        Details:    details,
                        Suggestion: "Some DNS pods are not running, check pod status and logs",
                }
        }</span>

        <span class="cov0" title="0">return output.CheckResult{
                Name:    "DNS Health",
                Status:  output.StatusPassed,
                Message: fmt.Sprintf("DNS is healthy: %d/%d pods running", runningDNSPods, len(dnsPods.Items)),
                Details: details,
        }</span>
}

// getNodeSuggestion returns appropriate suggestions for node issues
func (c *ClusterDiagnostic) getNodeSuggestion(issues []string) string <span class="cov8" title="1">{
        suggestions := []string{}

        for _, issue := range issues </span><span class="cov8" title="1">{
                switch issue </span>{
                case "NotReady":<span class="cov8" title="1">
                        suggestions = append(suggestions, "Check node status with 'kubectl describe node'")</span>
                case "MemoryPressure":<span class="cov8" title="1">
                        suggestions = append(suggestions, "Free up memory or add more nodes")</span>
                case "DiskPressure":<span class="cov8" title="1">
                        suggestions = append(suggestions, "Clean up disk space or add storage")</span>
                case "PIDPressure":<span class="cov0" title="0">
                        suggestions = append(suggestions, "Reduce running processes or increase PID limits")</span>
                case "NetworkUnavailable":<span class="cov0" title="0">
                        suggestions = append(suggestions, "Check network configuration and CNI")</span>
                }
        }

        <span class="cov8" title="1">if len(suggestions) &gt; 0 </span><span class="cov8" title="1">{
                return suggestions[0] // Return the first suggestion to avoid clutter
        }</span>
        <span class="cov8" title="1">return "Check node logs and status for more details"</span>
}

// getControlPlaneSuggestion returns suggestions for control plane issues
func (c *ClusterDiagnostic) getControlPlaneSuggestion(component string, running, total int) string <span class="cov8" title="1">{
        if running == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("Restart %s component or check its configuration", component)
        }</span>
        <span class="cov8" title="1">if running &lt; total </span><span class="cov8" title="1">{
                return fmt.Sprintf("Check %s pod logs for issues", component)
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// calculateSummary calculates the summary statistics for the checks
func (c *ClusterDiagnostic) calculateSummary(checks []output.CheckResult) output.Summary <span class="cov8" title="1">{
        summary := output.Summary{}

        for _, check := range checks </span><span class="cov8" title="1">{
                summary.Total++
                switch check.Status </span>{
                case output.StatusPassed:<span class="cov8" title="1">
                        summary.Passed++</span>
                case output.StatusFailed:<span class="cov8" title="1">
                        summary.Failed++</span>
                case output.StatusWarning:<span class="cov8" title="1">
                        summary.Warnings++</span>
                case output.StatusSkipped:<span class="cov8" title="1">
                        summary.Skipped++</span>
                }
        }

        <span class="cov8" title="1">return summary</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
